<?php

/**
 * Implementation of hook_requirements().
 */
function system_requirements($phase) {
  $requirements = array();
  // Ensure translations don't break at install time
  $t = get_t();

  // Report Drupal version
  if ($phase == 'runtime') {
    $requirements['drupal'] = array(
      'title' => $t('Drupal'),
      'value' => VERSION,
      'severity' => REQUIREMENT_INFO,
      'weight' => -10,
    );
  }

  // Web server information.
  $software = $_SERVER['SERVER_SOFTWARE'];
  $requirements['webserver'] = array(
    'title' => $t('Web server'),
    'value' => $software,
  );

  // Test PHP version
  $requirements['php'] = array(
    'title' => $t('PHP'),
    'value' => ($phase == 'runtime') ? l(phpversion(), 'admin/reports/status/php') : phpversion(),
  );
  if (version_compare(phpversion(), DRUPAL_MINIMUM_PHP) < 0) {
    $requirements['php']['description'] = $t('Your PHP installation is too old. Drupal requires at least PHP %version.', array('%version' => DRUPAL_MINIMUM_PHP));
    $requirements['php']['severity'] = REQUIREMENT_ERROR;
  }

  // Test PHP register_globals setting.
  $requirements['php_register_globals'] = array(
    'title' => $t('PHP register globals'),
  );
  $register_globals = trim(ini_get('register_globals'));
  // Unfortunately, ini_get() may return many different values, and we can't
  // be certain which values mean 'on', so we instead check for 'not off'
  // since we never want to tell the user that their site is secure
  // (register_globals off), when it is in fact on. We can only guarantee
  // register_globals is off if the value returned is 'off', '', or 0.
  if (!empty($register_globals) && strtolower($register_globals) != 'off') {
    $requirements['php_register_globals']['description'] = $t('<em>register_globals</em> is enabled. Drupal requires this configuration directive to be disabled. Your site may not be secure when <em>register_globals</em> is enabled. The PHP manual has instructions for <a href="http://php.net/configuration.changes">how to change configuration settings</a>.');
    $requirements['php_register_globals']['severity'] = REQUIREMENT_ERROR;
    $requirements['php_register_globals']['value'] = $t("Enabled ('@value')", array('@value' => $register_globals));
  }
  else {
    $requirements['php_register_globals']['value'] = $t('Disabled');
  }

  // Test PHP memory_limit
  $memory_limit = ini_get('memory_limit');
  $requirements['php_memory_limit'] = array(
    'title' => $t('PHP memory limit'),
    'value' => $memory_limit == -1 ? t('-1 (Unlimited)') : $memory_limit,
  );

  if ($memory_limit && $memory_limit != -1 && parse_size($memory_limit) < parse_size(DRUPAL_MINIMUM_PHP_MEMORY_LIMIT)) {
    $description = '';
    if ($phase == 'install') {
      $description = $t('Consider increasing your PHP memory limit to %memory_minimum_limit to help prevent errors in the installation process.', array('%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));
    }
    elseif ($phase == 'update') {
      $description = $t('Consider increasing your PHP memory limit to %memory_minimum_limit to help prevent errors in the update process.', array('%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));
    }
    elseif ($phase == 'runtime') {
      $description = $t('Depending on your configuration, Drupal can run with a %memory_limit PHP memory limit. However, a %memory_minimum_limit PHP memory limit or above is recommended, especially if your site uses additional custom or contributed modules.', array('%memory_limit' => $memory_limit, '%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));
    }

    if (!empty($description)) {
      if ($php_ini_path = get_cfg_var('cfg_file_path')) {
        $description .= ' '. $t('Increase the memory limit by editing the memory_limit parameter in the file %configuration-file and then restart your web server (or contact your system administrator or hosting provider for assistance).', array('%configuration-file' => $php_ini_path));
      }
      else {
        $description .= ' '. $t('Contact your system administrator or hosting provider for assistance with increasing your PHP memory limit.');
      }

      $requirements['php_memory_limit']['description'] = $description .' '. $t('See the <a href="@url">Drupal requirements</a> for more information.', array('@url' => 'http://drupal.org/requirements'));
      $requirements['php_memory_limit']['severity'] = REQUIREMENT_WARNING;
    }
  }

  // Test DB version
  global $db_type;
  if (function_exists('db_status_report')) {
    $requirements += db_status_report($phase);
  }

  // Test settings.php file writability
  if ($phase == 'runtime') {
    $conf_dir = drupal_verify_install_file(conf_path(), FILE_NOT_WRITABLE, 'dir');
    $conf_file = drupal_verify_install_file(conf_path() .'/settings.php', FILE_EXIST|FILE_READABLE|FILE_NOT_WRITABLE);
    if (!$conf_dir || !$conf_file) {
      $requirements['settings.php'] = array(
        'value' => $t('Not protected'),
        'severity' => REQUIREMENT_ERROR,
        'description' => '',
      );
      if (!$conf_dir) {
        $requirements['settings.php']['description'] .= $t('The directory %file is not protected from modifications and poses a security risk. You must change the directory\'s permissions to be non-writable. ', array('%file' => conf_path()));
      }
      if (!$conf_file) {
        $requirements['settings.php']['description'] .= $t('The file %file is not protected from modifications and poses a security risk. You must change the file\'s permissions to be non-writable.', array('%file' => conf_path() .'/settings.php'));
      }
    }
    else {
      $requirements['settings.php'] = array(
        'value' => $t('Protected'),
      );
    }
    $requirements['settings.php']['title'] = $t('Configuration file');
  }

  // Test the contents of the .htaccess files.
  if ($phase == 'runtime') {
    // Try to write the .htaccess files first, to prevent false alarms in case
    // (for example) the /tmp directory was wiped.
    file_create_htaccess(file_directory_path());
    file_create_htaccess(file_directory_temp());
    $htaccess_files['files_htaccess'] = array(
      'title' => $t('Files directory'),
      'directory' => file_directory_path(),
    );
    $htaccess_files['temporary_files_htaccess'] = array(
      'title' => $t('Temporary files directory'),
      'directory' => file_directory_temp(),
    );
    foreach ($htaccess_files as $key => $file_info) {
      // Check for the string which was added to the recommended .htaccess file
      // in the latest security update.
      $htaccess_file = $file_info['directory'] . '/.htaccess';
      if (!file_exists($htaccess_file) || !($contents = @file_get_contents($htaccess_file)) || strpos($contents, 'Drupal_Security_Do_Not_Remove_See_SA_2013_003') === FALSE) {
        $requirements[$key] = array(
          'title' => $file_info['title'],
          'value' => $t('Not fully protected'),
          'severity' => REQUIREMENT_ERROR,
          'description' => $t('See <a href="@url">@url</a> for information about the recommended .htaccess file which should be added to the %directory directory to help protect against arbitrary code execution.', array('@url' => 'http://drupal.org/SA-CORE-2013-003', '%directory' => $file_info['directory'])),
        );
      }
    }
  }

  // Report cron status.
  if ($phase == 'runtime') {
    // Cron warning threshold defaults to two days.
    $threshold_warning = variable_get('cron_threshold_warning', 172800);
    // Cron error threshold defaults to two weeks.
    $threshold_error = variable_get('cron_threshold_error', 1209600);
    // Cron configuration help text.
    $help = $t('For more information, see the online handbook entry for <a href="@cron-handbook">configuring cron jobs</a>.', array('@cron-handbook' => 'http://drupal.org/cron'));

    // Determine when cron last ran. If never, use the install time to
    // determine the warning or error status.
    $cron_last = variable_get('cron_last', NULL);
    $never_run = FALSE;
    if (!is_numeric($cron_last)) {
      $never_run = TRUE;
      $cron_last = variable_get('install_time', 0);
    }

    // Determine severity based on time since cron last ran.
    $severity = REQUIREMENT_OK;
    if (time() - $cron_last > $threshold_error) {
      $severity = REQUIREMENT_ERROR;
    }
    else if ($never_run || (time() - $cron_last > $threshold_warning)) {
      $severity = REQUIREMENT_WARNING;
    }

    // If cron hasn't been run, and the user is viewing the main
    // administration page, instead of an error, we display a helpful reminder
    // to configure cron jobs.
    if ($never_run && $severity != REQUIREMENT_ERROR && $_GET['q'] == 'admin' && user_access('administer site configuration')) {
      drupal_set_message($t('Cron has not run. Please visit the <a href="@status">status report</a> for more information.', array('@status' => url('admin/reports/status'))));
    }

    // Set summary and description based on values determined above.
    if ($never_run) {
      $summary = $t('Never run');
      $description = $t('Cron has not run.') .' '. $help;
    }
    else {
      $summary = $t('Last run !time ago', array('!time' => format_interval(time() - $cron_last)));
      $description = '';
      if ($severity != REQUIREMENT_OK) {
        $description = $t('Cron has not run recently.') .' '. $help;
      }
    }

    $requirements['cron'] = array(
      'title' => $t('Cron maintenance tasks'),
      'severity' => $severity,
      'value' => $summary,
      'description' => $description .' '. $t('You can <a href="@cron">run cron manually</a>.', array('@cron' => url('admin/reports/status/run-cron'))),
    );
  }

  // Test files directory
  $directory = file_directory_path();
  $requirements['file system'] = array(
    'title' => $t('File system'),
  );

  // For installer, create the directory if possible.
  if ($phase == 'install' && !is_dir($directory) && @mkdir($directory)) {
    @chmod($directory, 0775); // Necessary for non-webserver users.
  }

  $is_writable = is_writable($directory);
  $is_directory = is_dir($directory);
  if (!$is_writable || !$is_directory) {
    $description = '';
    $requirements['file system']['value'] = $t('Not writable');
    if (!$is_directory) {
      $error = $t('The directory %directory does not exist.', array('%directory' => $directory));
    }
    else {
      $error = $t('The directory %directory is not writable.', array('%directory' => $directory));
    }
    // The files directory requirement check is done only during install and runtime.
    if ($phase == 'runtime') {
      $description = $error .' '. $t('You may need to set the correct directory at the <a href="@admin-file-system">file system settings page</a> or change the current directory\'s permissions so that it is writable.', array('@admin-file-system' => url('admin/settings/file-system')));
    }
    elseif ($phase == 'install') {
      // For the installer UI, we need different wording. 'value' will
      // be treated as version, so provide none there.
      $description = $error .' '. $t('An automated attempt to create this directory failed, possibly due to a permissions problem. To proceed with the installation, either create the directory and modify its permissions manually, or ensure that the installer has the permissions to create it automatically. For more information, please see INSTALL.txt or the <a href="@handbook_url">on-line handbook</a>.', array('@handbook_url' => 'http://drupal.org/server-permissions'));
      $requirements['file system']['value'] = '';
    }
    if (!empty($description)) {
      $requirements['file system']['description'] = $description;
      $requirements['file system']['severity'] = REQUIREMENT_ERROR;
    }
  }
  else {
    if (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC) {
      $requirements['file system']['value'] = $t('Writable (<em>public</em> download method)');
    }
    else {
      $requirements['file system']['value'] = $t('Writable (<em>private</em> download method)');
    }
  }

  // See if updates are available in update.php.
  if ($phase == 'runtime') {
    $requirements['update'] = array(
      'title' => $t('Database updates'),
      'severity' => REQUIREMENT_OK,
      'value' => $t('Up to date'),
    );

    // Check installed modules.
    foreach (module_list() as $module) {
      $updates = drupal_get_schema_versions($module);
      if ($updates !== FALSE) {
        $default = drupal_get_installed_schema_version($module);
        if (max($updates) > $default) {
          $requirements['update']['severity'] = REQUIREMENT_ERROR;
          $requirements['update']['value'] = $t('Out of date');
          $requirements['update']['description'] = $t('Some modules have database schema updates to install. You should run the <a href="@update">database update script</a> immediately.', array('@update' => base_path() .'update.php'));
          break;
        }
      }
    }
  }

  // Verify the update.php access setting
  if ($phase == 'runtime') {
    if (!empty($GLOBALS['update_free_access'])) {
      $requirements['update access'] = array(
        'value' => $t('Not protected'),
        'severity' => REQUIREMENT_ERROR,
        'description' => $t('The update.php script is accessible to everyone without authentication check, which is a security risk. You must change the $update_free_access value in your settings.php back to FALSE.'),
      );
    }
    else {
      $requirements['update access'] = array(
        'value' => $t('Protected'),
      );
    }
    $requirements['update access']['title'] = $t('Access to update.php');
  }

  // Test Unicode library
  include_once './includes/unicode.inc';
  $requirements = array_merge($requirements, unicode_requirements());

  if ($phase == 'runtime') {
    // Check for update status module.
    if (!module_exists('update')) {
      $requirements['update status'] = array(
        'value' => $t('Not enabled'),
        'severity' => REQUIREMENT_WARNING,
        'description' => $t('Update notifications are not enabled. It is <strong>highly recommended</strong> that you enable the update status module from the <a href="@module">module administration page</a> in order to stay up-to-date on new releases. For more information please read the <a href="@update">Update status handbook page</a>.', array('@update' => 'http://drupal.org/handbook/modules/update', '@module' => url('admin/build/modules'))),
      );
    }
    else {
      $requirements['update status'] = array(
        'value' => $t('Enabled'),
      );
    }
    $requirements['update status']['title'] = $t('Update notifications');

    // Check that Drupal can issue HTTP requests.
    if (variable_get('drupal_http_request_fails', TRUE) && !system_check_http_request()) {
      $requirements['http requests'] = array(
        'title' => $t('HTTP request status'),
        'value' => $t('Fails'),
        'severity' => REQUIREMENT_ERROR,
        'description' => $t('Your system or network configuration does not allow Drupal to access web pages, resulting in reduced functionality. This could be due to your webserver configuration or PHP settings, and should be resolved in order to download information about available updates, fetch aggregator feeds, sign in via OpenID, or use other network-dependent services.'),
      );
    }
  }

  return $requirements;
}

/**
 * Implementation of hook_install().
 */
function system_install() {
  if ($GLOBALS['db_type'] == 'pgsql') {
    // We create some custom types and functions using global names instead of
    // prefixing them like we do with table names. If this function is ever
    // called again (for example, by the test framework when creating prefixed
    // test databases), the global names will already exist. We therefore avoid
    // trying to create them again in that case.

    // Create unsigned types.
    if (!db_result(db_query("SELECT COUNT(*) FROM pg_constraint WHERE conname = 'int_unsigned_check'"))) {
      db_query("CREATE DOMAIN int_unsigned integer CHECK (VALUE >= 0)");
    }
    if (!db_result(db_query("SELECT COUNT(*) FROM pg_constraint WHERE conname = 'smallint_unsigned_check'"))) {
      db_query("CREATE DOMAIN smallint_unsigned smallint CHECK (VALUE >= 0)");
    }
    if (!db_result(db_query("SELECT COUNT(*) FROM pg_constraint WHERE conname = 'bigint_unsigned_check'"))) {
      db_query("CREATE DOMAIN bigint_unsigned bigint CHECK (VALUE >= 0)");
    }

    // Create functions.
    db_query('CREATE OR REPLACE FUNCTION "greatest"(numeric, numeric) RETURNS numeric AS
      \'SELECT CASE WHEN (($1 > $2) OR ($2 IS NULL)) THEN $1 ELSE $2 END;\'
      LANGUAGE \'sql\''
    );
    db_query('CREATE OR REPLACE FUNCTION "greatest"(numeric, numeric, numeric) RETURNS numeric AS
      \'SELECT greatest($1, greatest($2, $3));\'
      LANGUAGE \'sql\''
    );
    if (!db_result(db_query("SELECT COUNT(*) FROM pg_proc WHERE proname = 'rand'"))) {
      db_query('CREATE OR REPLACE FUNCTION "rand"() RETURNS float AS
        \'SELECT random();\'
        LANGUAGE \'sql\''
      );
    }

    if (!db_result(db_query("SELECT COUNT(*) FROM pg_proc WHERE proname = 'concat'"))) {
      db_query('CREATE OR REPLACE FUNCTION "concat"(text, text) RETURNS text AS
        \'SELECT $1 || $2;\'
        LANGUAGE \'sql\''
      );
    }
    db_query('CREATE OR REPLACE FUNCTION "if"(boolean, text, text) RETURNS text AS
      \'SELECT CASE WHEN $1 THEN $2 ELSE $3 END;\'
      LANGUAGE \'sql\''
    );
    db_query('CREATE OR REPLACE FUNCTION "if"(boolean, integer, integer) RETURNS integer AS
      \'SELECT CASE WHEN $1 THEN $2 ELSE $3 END;\'
      LANGUAGE \'sql\''
    );
  }

  // Create tables.
  $modules = array('system', 'filter', 'block', 'user', 'node', 'comment', 'taxonomy');
  foreach ($modules as $module) {
    drupal_install_schema($module);
  }

  // Clear out module list and hook implementation statics before calling
  // system_theme_data().
  module_list(TRUE, FALSE);
  module_implements('', FALSE, TRUE);

  // Load system theme data appropriately.
  system_theme_data();

  // Inserting uid 0 here confuses MySQL -- the next user might be created as
  // uid 2 which is not what we want. So we insert the first user here, the
  // anonymous user. uid is 1 here for now, but very soon it will be changed
  // to 0.
  db_query("INSERT INTO {users} (name, mail) VALUES('%s', '%s')", '', '');

  // We need some placeholders here as name and mail are uniques and data is
  // presumed to be a serialized array. Install will change uid 1 immediately
  // anyways. So we insert the superuser here, the uid is 2 here for now, but
  // very soon it will be changed to 1.
  db_query("INSERT INTO {users} (name, mail, created, data) VALUES('%s', '%s', %d, '%s')", 'placeholder-for-uid-1', 'placeholder-for-uid-1', time(), serialize(array()));

  // This sets the above two users uid 0 (anonymous). We avoid an explicit 0
  // otherwise MySQL might insert the next auto_increment value.
  db_query("UPDATE {users} SET uid = uid - uid WHERE name = '%s'", '');

  // This sets uid 1 (superuser). We skip uid 2 but that's not a big problem.
  db_query("UPDATE {users} SET uid = 1 WHERE name = '%s'", 'placeholder-for-uid-1');

  db_query("INSERT INTO {role} (name) VALUES ('%s')", 'anonymous user');
  $rid_anonymous = db_last_insert_id('role', 'rid');

  db_query("INSERT INTO {role} (name) VALUES ('%s')", 'authenticated user');
  $rid_authenticated = db_last_insert_id('role', 'rid');

  // Sanity check to ensure the anonymous and authenticated role IDs are the 
  // same as the drupal defined constants. In certain situations, this will 
  // not be true
  if ($rid_anonymous != DRUPAL_ANONYMOUS_RID) {
    db_query("UPDATE {role} SET rid = %d WHERE rid = %d", DRUPAL_ANONYMOUS_RID, $rid_anonymous);
  }

  if ($rid_authenticated != DRUPAL_AUTHENTICATED_RID) {
    db_query("UPDATE {role} SET rid = %d WHERE rid = %d", DRUPAL_AUTHENTICATED_RID, $rid_authenticated);
  }

  db_query("INSERT INTO {permission} (rid, perm, tid) VALUES (%d, '%s', %d)", DRUPAL_ANONYMOUS_RID, 'access content', 0);
  db_query("INSERT INTO {permission} (rid, perm, tid) VALUES (%d, '%s', %d)", DRUPAL_AUTHENTICATED_RID, 'access comments, access content, post comments, post comments without approval', 0);

  db_query("INSERT INTO {variable} (name, value) VALUES ('%s', '%s')", 'theme_default', 's:7:"garland";');

  db_query("UPDATE {system} SET status = %d WHERE type = '%s' AND name = '%s'", 1, 'theme', 'garland');
  db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, pages, cache) VALUES ('%s', '%s', '%s', %d, %d, '%s', '%s', %d)", 'user', '0', 'garland', 1, 0, 'left', '', -1);
  db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, pages, cache) VALUES ('%s', '%s', '%s', %d, %d, '%s', '%s', %d)", 'user', '1', 'garland', 1, 0, 'left', '', -1);
  db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, pages, cache) VALUES ('%s', '%s', '%s', %d, %d, '%s', '%s', %d)", 'system', '0', 'garland', 1, 10, 'footer', '', -1);

  db_query("INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, '%s', %d, %d, %d)", 0, 0, 'all', 1, 0, 0);

  // Add input formats.
  db_query("INSERT INTO {filter_formats} (name, roles, cache) VALUES ('%s', '%s', %d)", 'Filtered HTML', ',' . DRUPAL_ANONYMOUS_RID . ',' . DRUPAL_AUTHENTICATED_RID . ',', 1);
  $filtered_html_format = db_last_insert_id('filter_formats', 'format');
  db_query("INSERT INTO {filter_formats} (name, roles, cache) VALUES ('%s', '%s', %d)", 'Full HTML', '', 1);
  $full_html_format = db_last_insert_id('filter_formats', 'format');

  // Enable filters for each input format.

  // Filtered HTML:
  // URL filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $filtered_html_format, 'filter', 2, 0);
  // HTML filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $filtered_html_format, 'filter', 0, 1);
  // Line break filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $filtered_html_format, 'filter', 1, 2);
  // HTML corrector filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $filtered_html_format, 'filter', 3, 10);

  // Full HTML:
  // URL filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $full_html_format, 'filter', 2, 0);
  // Line break filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $full_html_format, 'filter', 1, 1);
  // HTML corrector filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $full_html_format, 'filter', 3, 10);

  db_query("INSERT INTO {variable} (name, value) VALUES ('%s','%s')", 'filter_html_1', 'i:1;');
  db_query("INSERT INTO {variable} (name, value) VALUES ('%s', '%s')", 'node_options_forum', 'a:1:{i:0;s:6:"status";}');
}

/**
 * Implementation of hook_schema().
 */
function system_schema() {
  // NOTE: {variable} needs to be created before all other tables, as
  // some database drivers, e.g. Oracle and DB2, will require variable_get()
  // and variable_set() for overcoming some database specific limitations.
  $schema['variable'] = array(
    'description' => 'Named variable/value pairs created by Drupal core or any other module or theme. All variables are cached in memory at the start of every Drupal request so developers should not be careless about what is stored here.',
    'fields' => array(
      'name' => array(
        'description' => 'The name of the variable.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => ''),
      'value' => array(
        'description' => 'The value of the variable.',
        'type' => 'text',
        'not null' => TRUE,
        'size' => 'big'),
      ),
    'primary key' => array('name'),
    );

  $schema['actions'] = array(
    'description' => 'Stores action information.',
    'fields' => array(
      'aid' => array(
        'description' => 'Primary Key: Unique actions ID.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '0'),
      'type' => array(
        'description' => 'The object that that action acts on (node, user, comment, system or custom types.)',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => ''),
      'callback' => array(
        'description' => 'The callback function that executes when the action runs.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'parameters' => array(
        'description' => 'Parameters to be passed to the callback function.',
        'type' => 'text',
        'not null' => TRUE,
        'size' => 'big'),
      'description' => array(
        'description' => 'Description of the action.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '0'),
      ),
    'primary key' => array('aid'),
    );

  $schema['actions_aid'] = array(
    'description' => 'Stores action IDs for non-default actions.',
    'fields' => array(
      'aid' => array(
        'description' => 'Primary Key: Unique actions ID.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE),
      ),
    'primary key' => array('aid'),
    );

  $schema['batch'] = array(
    'description' => t('Stores details about batches (processes that run in multiple HTTP requests).'),
    'fields' => array(
      'bid' => array(
        'description' => 'Primary Key: Unique batch ID.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE),
      'token' => array(
        'description' => "A string token generated against the current user's session id and the batch id, used to ensure that only the user who submitted the batch can effectively access it.",
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE),
      'timestamp' => array(
        'description' => 'A Unix timestamp indicating when this batch was submitted for processing. Stale batches are purged at cron time.',
        'type' => 'int',
        'not null' => TRUE),
      'batch' => array(
        'description' => 'A serialized array containing the processing data for the batch.',
        'type' => 'text',
        'not null' => FALSE,
        'size' => 'big')
      ),
    'primary key' => array('bid'),
    'indexes' => array('token' => array('token')),
    );

  $schema['cache'] = array(
    'description' => 'Generic cache table for caching things not separated out into their own tables. Contributed modules may also use this to store cached items.',
    'fields' => array(
      'cid' => array(
        'description' => 'Primary Key: Unique cache ID.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'data' => array(
        'description' => 'A collection of data to cache.',
        'type' => 'blob',
        'not null' => FALSE,
        'size' => 'big'),
      'expire' => array(
        'description' => 'A Unix timestamp indicating when the cache entry should expire, or 0 for never.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'created' => array(
        'description' => 'A Unix timestamp indicating when the cache entry was created.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'headers' => array(
        'description' => 'Any custom HTTP headers to be added to cached data.',
        'type' => 'text',
        'not null' => FALSE),
      'serialized' => array(
        'description' => 'A flag to indicate whether content is serialized (1) or not (0).',
        'type' => 'int',
        'size' => 'small',
        'not null' => TRUE,
        'default' => 0)
      ),
    'indexes' => array('expire' => array('expire')),
    'primary key' => array('cid'),
    );

  $schema['cache_form'] = $schema['cache'];
  $schema['cache_form']['description'] = 'Cache table for the form system to store recently built forms and their storage data, to be used in subsequent page requests.';
  $schema['cache_page'] = $schema['cache'];
  $schema['cache_page']['description'] = 'Cache table used to store compressed pages for anonymous users, if page caching is enabled.';
  $schema['cache_menu'] = $schema['cache'];
  $schema['cache_menu']['description'] = 'Cache table for the menu system to store router information as well as generated link trees for various menu/page/user combinations.';

  $schema['files'] = array(
    'description' => 'Stores information for uploaded files.',
    'fields' => array(
      'fid' => array(
        'description' => 'Primary Key: Unique files ID.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE),
      'uid' => array(
        'description' => 'The {users}.uid of the user who is associated with the file.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'filename' => array(
        'description' => 'Name of the file.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'filepath' => array(
        'description' => 'Path of the file relative to Drupal root.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'filemime' => array(
        'description' => 'The file MIME type.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'filesize' => array(
        'description' => 'The size of the file in bytes.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'status' => array(
        'description' => 'A flag indicating whether file is temporary (0) or permanent (1).',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'timestamp' => array(
        'description' => 'UNIX timestamp for when the file was added.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      ),
    'indexes' => array(
      'uid' => array('uid'),
      'status' => array('status'),
      'timestamp' => array('timestamp'),
      ),
    'primary key' => array('fid'),
    );

  $schema['flood'] = array(
    'description' => 'Flood controls the threshold of events, such as the number of contact attempts.',
    'fields' => array(
      'fid' => array(
        'description' => 'Unique flood event ID.',
        'type' => 'serial',
        'not null' => TRUE),
      'event' => array(
        'description' => 'Name of event (e.g. contact).',
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => ''),
      'hostname' => array(
        'description' => 'Hostname of the visitor.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => ''),
      'timestamp' => array(
        'description' => 'Timestamp of the event.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0)
      ),
    'primary key' => array('fid'),
    'indexes' => array(
      'allow' => array('event', 'hostname', 'timestamp'),
    ),
    );

  $schema['history'] = array(
    'description' => 'A record of which {users} have read which {node}s.',
    'fields' => array(
      'uid' => array(
        'description' => 'The {users}.uid that read the {node} nid.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'nid' => array(
        'description' => 'The {node}.nid that was read.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'timestamp' => array(
        'description' => 'The Unix timestamp at which the read occurred.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0)
      ),
    'primary key' => array('uid', 'nid'),
    'indexes' => array(
      'nid' => array('nid'),
    ),
    );
  $schema['menu_router'] = array(
    'description' => 'Maps paths to various callbacks (access, page and title)',
    'fields' => array(
      'path' => array(
        'description' => 'Primary Key: the Drupal path this entry describes',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'load_functions' => array(
        'description' => 'A serialized array of function names (like node_load) to be called to load an object corresponding to a part of the current path.',
        'type' => 'text',
        'not null' => TRUE,),
      'to_arg_functions' => array(
        'description' => 'A serialized array of function names (like user_uid_optional_to_arg) to be called to replace a part of the router path with another string.',
        'type' => 'text',
        'not null' => TRUE,),
      'access_callback' => array(
        'description' => 'The callback which determines the access to this router path. Defaults to user_access.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'access_arguments' => array(
        'description' => 'A serialized array of arguments for the access callback.',
        'type' => 'text',
        'not null' => FALSE),
      'page_callback' => array(
        'description' => 'The name of the function that renders the page.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'page_arguments' => array(
        'description' => 'A serialized array of arguments for the page callback.',
        'type' => 'text',
        'not null' => FALSE),
      'fit' => array(
        'description' => 'A numeric representation of how specific the path is.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'number_parts' => array(
        'description' => 'Number of parts in this router path.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'tab_parent' => array(
        'description' => 'Only for local tasks (tabs) - the router path of the parent page (which may also be a local task).',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'tab_root' => array(
        'description' => 'Router path of the closest non-tab parent page. For pages that are not local tasks, this will be the same as the path.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'title' => array(
        'description' => 'The title for the current page, or the title for the tab if this is a local task.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'title_callback' => array(
        'description' => 'A function which will alter the title. Defaults to t()',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'title_arguments' => array(
        'description' => 'A serialized array of arguments for the title callback. If empty, the title will be used as the sole argument for the title callback.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'type' => array(
        'description' => 'Numeric representation of the type of the menu item, like MENU_LOCAL_TASK.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'block_callback' => array(
        'description' => 'Name of a function used to render the block on the system administration page for this item.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'description' => array(
        'description' => 'A description of this item.',
        'type' => 'text',
        'not null' => TRUE),
      'position' => array(
        'description' => 'The position of the block (left or right) on the system administration page for this item.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'weight' => array(
        'description' => 'Weight of the element. Lighter weights are higher up, heavier weights go down.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'file' => array(
        'description' => 'The file to include for this element, usually the page callback function lives in this file.',
        'type' => 'text',
        'size' => 'medium')
      ),
    'indexes' => array(
      'fit' => array('fit'),
      'tab_parent' => array('tab_parent'),
      'tab_root_weight_title' => array(array('tab_root', 64), 'weight', 'title'),      
      ),
    'primary key' => array('path'),
    );

  $schema['menu_links'] = array(
    'description' => 'Contains the individual links within a menu.',
    'fields' => array(
     'menu_name' => array(
        'description' => "The menu name. All links with the same menu name (such as 'navigation') are part of the same menu.",
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => ''),
      'mlid' => array(
        'description' => 'The menu link ID (mlid) is the integer primary key.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE),
      'plid' => array(
        'description' => 'The parent link ID (plid) is the mlid of the link above in the hierarchy, or zero if the link is at the top level in its menu.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'link_path' => array(
        'description' => 'The Drupal path or external path this link points to.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'router_path' => array(
        'description' => 'For links corresponding to a Drupal path (external = 0), this connects the link to a {menu_router}.path for joins.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'link_title' => array(
      'description' => 'The text displayed for the link, which may be modified by a title callback stored in {menu_router}.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'options' => array(
        'description' => 'A serialized array of options to be passed to the url() or l() function, such as a query string or HTML attributes.',
        'type' => 'text',
        'not null' => FALSE),
      'module' => array(
        'description' => 'The name of the module that generated this link.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => 'system'),
      'hidden' => array(
        'description' => 'A flag for whether the link should be rendered in menus. (1 = a disabled menu item that may be shown on admin screens, -1 = a menu callback, 0 = a normal, visible link)',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'external' => array(
        'description' => 'A flag to indicate if the link points to a full URL starting with a protocol, like http:// (1 = external, 0 = internal).',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'has_children' => array(
        'description' => 'Flag indicating whether any links have this link as a parent (1 = children exist, 0 = no children).',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'expanded' => array(
        'description' => 'Flag for whether this link should be rendered as expanded in menus - expanded links always have their child links displayed, instead of only when the link is in the active trail (1 = expanded, 0 = not expanded)',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'weight' => array(
        'description' => 'Link weight among links in the same menu at the same depth.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'depth' => array(
        'description' => 'The depth relative to the top level. A link with plid == 0 will have depth == 1.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'customized' => array(
        'description' => 'A flag to indicate that the user has manually created or edited the link (1 = customized, 0 = not customized).',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'p1' => array(
        'description' => 'The first mlid in the materialized path. If N = depth, then pN must equal the mlid. If depth > 1 then p(N-1) must equal the plid. All pX where X > depth must equal zero. The columns p1 .. p9 are also called the parents.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p2' => array(
        'description' => 'The second mlid in the materialized path. See p1.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p3' => array(
        'description' => 'The third mlid in the materialized path. See p1.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p4' => array(
        'description' => 'The fourth mlid in the materialized path. See p1.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p5' => array(
        'description' => 'The fifth mlid in the materialized path. See p1.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p6' => array(
        'description' => 'The sixth mlid in the materialized path. See p1.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p7' => array(
        'description' => 'The seventh mlid in the materialized path. See p1.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p8' => array(
        'description' => 'The eighth mlid in the materialized path. See p1.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p9' => array(
        'description' => 'The ninth mlid in the materialized path. See p1.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'updated' => array(
        'description' => 'Flag that indicates that this link was generated during the update from Drupal 5.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      ),
    'indexes' => array(
      'path_menu' => array(array('link_path', 128), 'menu_name'),
      'menu_plid_expand_child' => array(
        'menu_name', 'plid', 'expanded', 'has_children'),
      'menu_parents' => array(
        'menu_name', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7', 'p8', 'p9'),
      'router_path' => array(array('router_path', 128)),
      ),
    'primary key' => array('mlid'),
    );

  $schema['semaphore'] = array(
    'description' => 'Table for holding semaphores, locks, flags, etc. that cannot be stored as Drupal variables since they must not be cached.',
    'fields' => array(
      'name' => array(
        'description' => 'Primary Key: Unique name.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'value' => array(
        'description' => 'A value.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'expire' => array(
        'description' => 'A Unix timestamp with microseconds indicating when the semaphore should expire.',
        'type' => 'float',
        'size' => 'big',
        'not null' => TRUE),
      ),
    'indexes' => array('expire' => array('expire')),
    'primary key' => array('name'),
    );

  $schema['sessions'] = array(
    'description' => "Drupal's session handlers read and write into the sessions table. Each record represents a user session, either anonymous or authenticated.",
    'fields' => array(
      'uid' => array(
        'description' => 'The {users}.uid corresponding to a session, or 0 for anonymous user.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE),
      'sid' => array(
        'description' => "Primary key: A session ID. The value is generated by PHP's Session API.",
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => ''),
      'hostname' => array(
        'description' => 'The IP address that last used this session ID (sid).',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => ''),
      'timestamp' => array(
        'description' => 'The Unix timestamp when this session last requested a page. Old records are purged by PHP automatically.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'cache' => array(
        'description' => "The time of this user's last post. This is used when the site has specified a minimum_cache_lifetime. See cache_get().",
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'session' => array(
        'description' => 'The serialized contents of $_SESSION, an array of name/value pairs that persists across page requests by this session ID. Drupal loads $_SESSION from here at the start of each request and saves it at the end.',
        'type' => 'blob',
        'not null' => FALSE,
        'size' => 'big')
      ),
    'primary key' => array('sid'),
    'indexes' => array(
      'timestamp' => array('timestamp'),
      'uid' => array('uid')
      ),
    );

  $schema['system'] = array(
    'description' => "A list of all modules, themes, and theme engines that are or have been installed in Drupal's file system.",
    'fields' => array(
      'filename' => array(
        'description' => 'The path of the primary file for this item, relative to the Drupal root; e.g. modules/node/node.module.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'name' => array(
        'description' => 'The name of the item; e.g. node.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'type' => array(
        'description' => 'The type of the item, either module, theme, or theme_engine.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'owner' => array(
        'description' => "A theme's 'parent'. Can be either a theme or an engine.",
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'status' => array(
        'description' => 'Boolean indicating whether or not this item is enabled.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'throttle' => array(
        'description' => 'Boolean indicating whether this item is disabled when the throttle.module disables throttleable items.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'tiny'),
      'bootstrap' => array(
        'description' => "Boolean indicating whether this module is loaded during Drupal's early bootstrapping phase (e.g. even before the page cache is consulted).",
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'schema_version' => array(
        'description' => "The module's database schema version number. -1 if the module is not installed (its tables do not exist); 0 or the largest N of the module's hook_update_N() function that has either been run or existed when the module was first installed.",
        'type' => 'int',
        'not null' => TRUE,
        'default' => -1,
        'size' => 'small'),
      'weight' => array(
        'description' => "The order in which this module's hooks should be invoked relative to other modules. Equal-weighted modules are ordered by name.",
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'info' => array(
        'description' => "A serialized array containing information from the module's .info file; keys can include name, description, package, version, core, dependencies, dependents, and php.",
        'type' => 'text',
        'not null' => FALSE)
      ),
    'primary key' => array('filename'),
    'indexes' =>
      array(
        'modules' => array(array('type', 12), 'status', 'weight', 'filename'),
        'bootstrap' => array(array('type', 12), 'status', 'bootstrap', 'weight', 'filename'),
        'type_name' => array(array('type', 12), 'name'),
      ),
    );

  $schema['url_alias'] = array(
    'description' => 'A list of URL aliases for Drupal paths; a user may visit either the source or destination path.',
    'fields' => array(
      'pid' => array(
        'description' => 'A unique path alias identifier.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE),
      'src' => array(
        'description' => 'The Drupal path this alias is for; e.g. node/12.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => ''),
      'dst' => array(
        'description' => 'The alias for this path; e.g. title-of-the-story.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => ''),
      'language' => array(
        'description' => 'The language this alias is for; if blank, the alias will be used for unknown languages. Each Drupal path can have an alias for each supported language.',
        'type' => 'varchar',
        'length' => 12,
        'not null' => TRUE,
        'default' => '')
      ),
    'unique keys' => array('dst_language_pid' => array('dst', 'language', 'pid')),
    'primary key' => array('pid'),
    'indexes' => array('src_language_pid' => array('src', 'language', 'pid')),
    );

  return $schema;
}

// Updates for core.

function system_update_last_removed() {
  return 1021;
}

/**
 * @defgroup updates-5.x-extra Extra system updates for 5.x
 * @{
 */

/**
 * Add index on users created column.
 */
function system_update_1022() {
  $ret = array();
  db_add_index($ret, 'users', 'created', array('created'));
  // Also appears as system_update_6004(). Ensure we don't update twice.
  variable_set('system_update_1022', TRUE);
  return $ret;
}

/**
 * @} End of "defgroup updates-5.x-extra".
 */

/**
 * @defgroup updates-5.x-to-6.x System updates from 5.x to 6.x
 * @{
 */

/**
 * Remove auto_increment from {boxes} to allow adding custom blocks with
 * visibility settings.
 */
function system_update_6000() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $max = (int)db_result(db_query('SELECT MAX(bid) FROM {boxes}'));
      $ret[] = update_sql('ALTER TABLE {boxes} CHANGE COLUMN bid bid int NOT NULL');
      $ret[] = update_sql("REPLACE INTO {sequences} VALUES ('{boxes}_bid', $max)");
      break;
  }
  return $ret;
}

/**
 * Add version id column to {term_node} to allow taxonomy module to use revisions.
 */
function system_update_6001() {
  $ret = array();

  // Add vid to term-node relation.  The schema says it is unsigned.
  db_add_field($ret, 'term_node', 'vid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_drop_primary_key($ret, 'term_node');
  db_add_primary_key($ret, 'term_node', array('vid', 'tid', 'nid'));
  db_add_index($ret, 'term_node', 'vid', array('vid'));

  db_query('UPDATE {term_node} SET vid = (SELECT vid FROM {node} n WHERE {term_node}.nid = n.nid)');
  return $ret;
}

/**
 * Increase the maximum length of variable names from 48 to 128.
 */
function system_update_6002() {
  $ret = array();
  db_drop_primary_key($ret, 'variable');
  db_change_field($ret, 'variable', 'name', 'name', array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''));
  db_add_primary_key($ret, 'variable', array('name'));
  return $ret;
}

/**
 * Add index on comments status column.
 */
function system_update_6003() {
  $ret = array();
  db_add_index($ret, 'comments', 'status', array('status'));
  return $ret;
}

/**
 * This update used to add an index on users created column (#127941).
 * However, system_update_1022() does the same thing.  This update
 * tried to detect if 1022 had already run but failed to do so,
 * resulting in an "index already exists" error.
 *
 * Adding the index here is never necessary.  Sites installed before
 * 1022 will run 1022, getting the update.  Sites installed on/after 1022
 * got the index when the table was first created.  Therefore, this
 * function is now a no-op.
 */
function system_update_6004() {
  return array();
}

/**
 * Add language to url_alias table and modify indexes.
 */
function system_update_6005() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'url_alias', 'language', 'varchar(12)', array('default' => "''", 'not null' => TRUE));

      // As of system.install:1.85 (before the new language
      // subsystem), new installs got a unique key named
      // url_alias_dst_key on url_alias.dst.  Unfortunately,
      // system_update_162 created a unique key inconsistently named
      // url_alias_dst_idx on url_alias.dst (keys should have the _key
      // suffix, indexes the _idx suffix).  Therefore, sites installed
      // before system_update_162 have a unique key with a different
      // name than sites installed after system_update_162().  Now, we
      // want to drop the unique key on dst which may have either one
      // of two names and create a new unique key on (dst, language).
      // There is no way to know which key name exists so we have to
      // drop both, causing an SQL error.  Thus, we just hide the
      // error and only report the update_sql results that work.
      $err = error_reporting(0);
      $ret1 = update_sql('DROP INDEX {url_alias}_dst_idx');
      if ($ret1['success']) {
  $ret[] = $ret1;
      }
      $ret1 = array();
      db_drop_unique_key($ret, 'url_alias', 'dst');
      foreach ($ret1 as $r) {
  if ($r['success']) {
    $ret[] = $r;
  }
      }
      error_reporting($err);

      $ret[] = update_sql('CREATE UNIQUE INDEX {url_alias}_dst_language_idx ON {url_alias}(dst, language)');
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {url_alias} ADD language varchar(12) NOT NULL default ''");
      $ret[] = update_sql("ALTER TABLE {url_alias} DROP INDEX dst");
      $ret[] = update_sql("ALTER TABLE {url_alias} ADD UNIQUE dst_language (dst, language)");
      break;
  }
  return $ret;
}

/**
 * Drop useless indices on node_counter table.
 */
function system_update_6006() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      $ret[] = update_sql('DROP INDEX {node_counter}_daycount_idx');
      $ret[] = update_sql('DROP INDEX {node_counter}_totalcount_idx');
      $ret[] = update_sql('DROP INDEX {node_counter}_timestamp_idx');
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX daycount");
      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX totalcount");
      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX timestamp");
      break;
  }
  return $ret;
}

/**
 * Change the severity column in the watchdog table to the new values.
 */
function system_update_6007() {
  $ret = array();
  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_NOTICE ." WHERE severity = 0");
  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_WARNING ." WHERE severity = 1");
  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_ERROR ." WHERE severity = 2");
  return $ret;
}

/**
 * Add info files to themes.  The info and owner columns are added by
 * update_fix_d6_requirements() in update.php to avoid a large number
 * of error messages from update.php.  All we need to do here is copy
 * description to owner and then drop description.
 */
function system_update_6008() {
  $ret = array();
  $ret[] = update_sql('UPDATE {system} SET owner = description');
  db_drop_field($ret, 'system', 'description');

  // Rebuild system table contents.
  module_rebuild_cache();
  system_theme_data();

  return $ret;
}

/**
 * The PHP filter is now a separate module.
 */
function system_update_6009() {
  $ret = array();

  // If any input format used the Drupal 5 PHP filter.
  if (db_result(db_query("SELECT COUNT(format) FROM {filters} WHERE module = 'filter' AND delta = 1"))) {
    // Enable the PHP filter module.
    $ret[] = update_sql("UPDATE {system} SET status = 1 WHERE name = 'php' AND type = 'module'");
    // Update the input filters.
    $ret[] = update_sql("UPDATE {filters} SET delta = 0, module = 'php' WHERE module = 'filter' AND delta = 1");
  }

  // With the removal of the PHP evaluator filter, the deltas of the line break
  // and URL filter have changed.
  $ret[] = update_sql("UPDATE {filters} SET delta = 1 WHERE module = 'filter' AND delta = 2");
  $ret[] = update_sql("UPDATE {filters} SET delta = 2 WHERE module = 'filter' AND delta = 3");

  return $ret;
}

/**
 * Add variable replacement for watchdog messages.
 *
 * The variables field is NOT NULL and does not have a default value.
 * Existing log messages should not be translated in the new system,
 * so we insert 'N;' (serialize(NULL)) as the temporary default but
 * then remove the default value to match the schema.
 */
function system_update_6010() {
  $ret = array();
  db_add_field($ret, 'watchdog', 'variables', array('type' => 'text', 'size' => 'big', 'not null' => TRUE, 'initial' => 'N;'));
  return $ret;
}

/**
 * Add language support to nodes
 */
function system_update_6011() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'node', 'language', 'varchar(12)', array('default' => "''", 'not null' => TRUE));
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {node} ADD language varchar(12) NOT NULL default ''");
      break;
  }
  return $ret;
}

/**
 * Add serialized field to cache tables.  This is now handled directly
 * by update.php, so this function is a no-op.
 */
function system_update_6012() {
  return array();
}

/**
 * Rebuild cache data for theme system changes
 */
function system_update_6013() {
  // Rebuild system table contents.
  module_rebuild_cache();
  system_theme_data();

  return array(array('success' => TRUE, 'query' => 'Cache rebuilt.'));
}

/**
 * Record that the installer is done, so it is not
 * possible to run the installer on upgraded sites.
 */
function system_update_6014() {
  variable_set('install_task', 'done');

  return array(array('success' => TRUE, 'query' => "variable_set('install_task')"));
}

/**
 * Add the form cache table.
 */
function system_update_6015() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      $ret[] = update_sql("CREATE TABLE {cache_form} (
        cid varchar(255) NOT NULL default '',
        data bytea,
        expire int NOT NULL default '0',
        created int NOT NULL default '0',
        headers text,
        serialized smallint NOT NULL default '0',
        PRIMARY KEY (cid)
    )");
      $ret[] = update_sql("CREATE INDEX {cache_form}_expire_idx ON {cache_form} (expire)");
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("CREATE TABLE {cache_form} (
        cid varchar(255) NOT NULL default '',
        data longblob,
        expire int NOT NULL default '0',
        created int NOT NULL default '0',
        headers text,
        serialized int(1) NOT NULL default '0',
        PRIMARY KEY (cid),
        INDEX expire (expire)
      ) /*!40100 DEFAULT CHARACTER SET UTF8 */ ");
      break;
  }

  return $ret;
}

/**
 * Make {node}'s primary key be nid, change nid,vid to a unique key.
 * Add primary keys to block, filters, flood, permission, and term_relation.
 */
function system_update_6016() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      $ret[] = update_sql("ALTER TABLE {node} ADD CONSTRAINT {node}_nid_vid_key UNIQUE (nid, vid)");
      db_add_column($ret, 'blocks', 'bid', 'serial');
      $ret[] = update_sql("ALTER TABLE {blocks} ADD PRIMARY KEY (bid)");
      db_add_column($ret, 'filters', 'fid', 'serial');
      $ret[] = update_sql("ALTER TABLE {filters} ADD PRIMARY KEY (fid)");
      db_add_column($ret, 'flood', 'fid', 'serial');
      $ret[] = update_sql("ALTER TABLE {flood} ADD PRIMARY KEY (fid)");
      db_add_column($ret, 'permission', 'pid', 'serial');
      $ret[] = update_sql("ALTER TABLE {permission} ADD PRIMARY KEY (pid)");
      db_add_column($ret, 'term_relation', 'trid', 'serial');
      $ret[] = update_sql("ALTER TABLE {term_relation} ADD PRIMARY KEY (trid)");
      db_add_column($ret, 'term_synonym', 'tsid', 'serial');
      $ret[] = update_sql("ALTER TABLE {term_synonym} ADD PRIMARY KEY (tsid)");
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql('ALTER TABLE {node} ADD UNIQUE KEY nid_vid (nid, vid)');
      $ret[] = update_sql("ALTER TABLE {blocks} ADD bid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {filters} ADD fid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {flood} ADD fid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {permission} ADD pid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {term_relation} ADD trid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {term_synonym} ADD tsid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      break;
  }

  return $ret;
}

/**
 * Rename settings related to user.module email notifications.
 */
function system_update_6017() {
  $ret = array();
  // Maps old names to new ones.
  $var_names = array(
    'admin'    => 'register_admin_created',
    'approval' => 'register_pending_approval',
    'welcome'  => 'register_no_approval_required',
    'pass'     => 'password_reset',
  );
  foreach ($var_names as $old => $new) {
    foreach (array('_subject', '_body') as $suffix) {
      $old_name = 'user_mail_'. $old . $suffix;
      $new_name = 'user_mail_'. $new . $suffix;
      if ($old_val = variable_get($old_name, FALSE)) {
        variable_set($new_name, $old_val);
        variable_del($old_name);
        $ret[] = array('success' => TRUE, 'query' => "variable_set($new_name)");
        $ret[] = array('success' => TRUE, 'query' => "variable_del($old_name)");
        if ($old_name == 'user_mail_approval_body') {
          drupal_set_message('Saving an old value of the welcome message body for users that are pending administrator approval. However, you should consider modifying this text, since Drupal can now be configured to automatically notify users and send them their login information when their accounts are approved. See the <a href="'. url('admin/user/settings') .'">User settings</a> page for details.');
        }
      }
    }
  }
  return $ret;
}

/**
 * Add HTML corrector to HTML formats or replace the old module if it was in use.
 */
function system_update_6018() {
  $ret = array();

  // Disable htmlcorrector.module, if it exists and replace its filter.
  if (module_exists('htmlcorrector')) {
    module_disable(array('htmlcorrector'));
    $ret[] = update_sql("UPDATE {filter_formats} SET module = 'filter', delta = 3 WHERE module = 'htmlcorrector'");
    $ret[] = array('success' => TRUE, 'query' => 'HTML Corrector module was disabled; this functionality has now been added to core.');
    return $ret;
  }

  // Otherwise, find any format with 'HTML' in its name and add the filter at the end.
  $result = db_query("SELECT format, name FROM {filter_formats} WHERE name LIKE '%HTML%'");
  while ($format = db_fetch_object($result)) {
    $weight = db_result(db_query("SELECT MAX(weight) FROM {filters} WHERE format = %d", $format->format));
    db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $format->format, 'filter', 3, max(10, $weight + 1));
    $ret[] = array('success' => TRUE, 'query' => "HTML corrector filter added to the '". $format->name ."' input format.");
  }

  return $ret;
}

/**
 * Reconcile small differences in the previous, manually created mysql
 * and pgsql schemas so they are the same and can be represented by a
 * single schema structure.
 *
 * Note that the mysql and pgsql cases make different changes.  This
 * is because each schema needs to be tweaked in different ways to
 * conform to the new schema structure.  Also, since they operate on
 * tables defined by many optional core modules which may not ever
 * have been installed, they must test each table for existence.  If
 * the modules are first installed after this update exists the tables
 * will be created from the schema structure and will start out
 * correct.
 */
function system_update_6019() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      // Remove default ''.
      if (db_table_exists('aggregator_feed')) {
        db_field_set_no_default($ret, 'aggregator_feed', 'description');
        db_field_set_no_default($ret, 'aggregator_feed', 'image');
      }
      db_field_set_no_default($ret, 'blocks', 'pages');
      if (db_table_exists('contact')) {
        db_field_set_no_default($ret, 'contact', 'recipients');
        db_field_set_no_default($ret, 'contact', 'reply');
      }
      db_field_set_no_default($ret, 'watchdog', 'location');
      db_field_set_no_default($ret, 'node_revisions', 'body');
      db_field_set_no_default($ret, 'node_revisions', 'teaser');
      db_field_set_no_default($ret, 'node_revisions', 'log');

      // Update from pgsql 'float' (which means 'double precision') to
      // schema 'float' (which in pgsql means 'real').
      if (db_table_exists('search_index')) {
        db_change_field($ret, 'search_index', 'score', 'score', array('type' => 'float'));
      }
      if (db_table_exists('search_total')) {
        db_change_field($ret, 'search_total', 'count', 'count', array('type' => 'float'));
      }

      // Replace unique index dst_language with a unique constraint.  The
      // result is the same but the unique key fits our current schema
      // structure.  Also, the postgres documentation implies that
      // unique constraints are preferable to unique indexes.  See
      // http://www.postgresql.org/docs/8.2/interactive/indexes-unique.html.
      if (db_table_exists('url_alias')) {
        db_drop_index($ret, 'url_alias', 'dst_language');
        db_add_unique_key($ret, 'url_alias', 'dst_language',
          array('dst', 'language'));
      }

      // Fix term_node pkey: mysql and pgsql code had different orders.
      if (db_table_exists('term_node')) {
        db_drop_primary_key($ret, 'term_node');
        db_add_primary_key($ret, 'term_node', array('vid', 'tid', 'nid'));
      }

      // Make boxes.bid unsigned.
      db_drop_primary_key($ret, 'boxes');
      db_change_field($ret, 'boxes', 'bid', 'bid', array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array('bid')));

      // Fix primary key
      db_drop_primary_key($ret, 'node');
      db_add_primary_key($ret, 'node', array('nid'));

      break;

    case 'mysql':
    case 'mysqli':
      // Rename key 'link' to 'url'.
      if (db_table_exists('aggregator_feed')) {
        db_drop_unique_key($ret, 'aggregator_feed', 'link');
        db_add_unique_key($ret, 'aggregator_feed', 'url', array('url'));
      }

      // Change to size => small.
      if (db_table_exists('boxes')) {
        db_change_field($ret, 'boxes', 'format', 'format', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));
      }

      // Change to size => small.
      // Rename index 'lid' to 'nid'.
      if (db_table_exists('comments')) {
        db_change_field($ret, 'comments', 'format', 'format', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));
        db_drop_index($ret, 'comments', 'lid');
        db_add_index($ret, 'comments', 'nid', array('nid'));
      }

      // Change to size => small.
      db_change_field($ret, 'cache', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));
      db_change_field($ret, 'cache_filter', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));
      db_change_field($ret, 'cache_page', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));
      db_change_field($ret, 'cache_form', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));

      // Remove default => 0, set auto increment.
      $new_uid = 1 + db_result(db_query('SELECT MAX(uid) FROM {users}'));
      $ret[] = update_sql('UPDATE {users} SET uid = '. $new_uid .' WHERE uid = 0');
      db_drop_primary_key($ret, 'users');
      db_change_field($ret, 'users', 'uid', 'uid', array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array('uid')));
      $ret[] = update_sql('UPDATE {users} SET uid = 0 WHERE uid = '. $new_uid);

      // Special field names.
      $map = array('node_revisions' => 'vid');
      // Make sure these tables have proper auto_increment fields.
      foreach (array('boxes', 'files', 'node', 'node_revisions') as $table) {
        $field = isset($map[$table]) ? $map[$table] : $table[0] .'id';
        db_drop_primary_key($ret, $table);
        db_change_field($ret, $table, $field, $field, array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array($field)));
      }

      break;
  }

  return $ret;
}

/**
 * Create the tables for the new menu system.
 */
function system_update_6020() {
  $ret = array();

  $schema['menu_router'] = array(
    'fields' => array(
      'path'             => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'load_functions'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'to_arg_functions' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'access_callback'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'access_arguments' => array('type' => 'text', 'not null' => FALSE),
      'page_callback'    => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'page_arguments'   => array('type' => 'text', 'not null' => FALSE),
      'fit'              => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'number_parts'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'tab_parent'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'tab_root'         => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'title'            => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'title_callback'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'title_arguments'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'type'             => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'block_callback'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'description'      => array('type' => 'text', 'not null' => TRUE),
      'position'         => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'weight'           => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'file'             => array('type' => 'text', 'size' => 'medium')
    ),
    'indexes' => array(
      'fit'        => array('fit'),
      'tab_parent' => array('tab_parent')
    ),
    'primary key' => array('path'),
  );

  $schema['menu_links'] = array(
    'fields' => array(
      'menu_name'    => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'mlid'         => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE),
      'plid'         => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'link_path'    => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'router_path'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'link_title'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'options'      => array('type' => 'text', 'not null' => FALSE),
      'module'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => 'system'),
      'hidden'       => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'external'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'has_children' => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'expanded'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'weight'       => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'depth'        => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'customized'   => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'p1'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p2'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p3'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p4'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p5'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p6'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p7'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p8'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p9'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'updated'      => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
    ),
    'indexes' => array(
      'path_menu'              => array(array('link_path', 128), 'menu_name'),
      'menu_plid_expand_child' => array('menu_name', 'plid', 'expanded', 'has_children'),
      'menu_parents'           => array('menu_name', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7', 'p8', 'p9'),
      'router_path'            => array(array('router_path', 128)),
    ),
    'primary key' => array('mlid'),
  );

  foreach ($schema as $name => $table) {
    db_create_table($ret, $name, $table);
  }
  return $ret;
}

/**
 * Migrate the menu items from the old menu system to the new menu_links table.
 */
function system_update_6021() {
  $ret = array('#finished' => 0);
  $menus = array(
    'navigation' => array(
      'menu_name' => 'navigation',
      'title' => 'Navigation',
      'description' => 'The navigation menu is provided by Drupal and is the main interactive menu for any site. It is usually the only menu that contains personalized links for authenticated users, and is often not even visible to anonymous users.',
    ),
    'primary-links' => array(
      'menu_name' => 'primary-links',
      'title' => 'Primary links',
      'description' => 'Primary links are often used at the theme layer to show the major sections of a site. A typical representation for primary links would be tabs along the top.',
    ),
    'secondary-links' => array(
      'menu_name' => 'secondary-links',
      'title' => 'Secondary links',
      'description' => 'Secondary links are often used for pages like legal notices, contact details, and other secondary navigation items that play a lesser role than primary links.',
    ),
  );
  // Multi-part update
  if (!isset($_SESSION['system_update_6021'])) {
    db_add_field($ret, 'menu', 'converted', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0, 'size' => 'tiny'));
    $_SESSION['system_update_6021_max'] = db_result(db_query('SELECT COUNT(*) FROM {menu}'));
    $_SESSION['menu_menu_map'] = array(1 => 'navigation');
    // 0 => FALSE is for new menus, 1 => FALSE is for the navigation.
    $_SESSION['menu_item_map'] = array(0 => FALSE, 1 => FALSE);
    $table = array(
      'fields' => array(
        'menu_name'   => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
        'title'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
        'description' => array('type' => 'text', 'not null' => FALSE),
      ),
      'primary key' => array('menu_name'),
    );
    db_create_table($ret, 'menu_custom', $table);
    db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", $menus['navigation']);
    $_SESSION['system_update_6021'] = 0;
  }

  $limit = 50;
  while ($limit-- && ($item = db_fetch_array(db_query_range('SELECT * FROM {menu} WHERE converted = 0', 0, 1)))) {
    // If it's not a menu...
    if ($item['pid']) {
      // Let's climb up until we find an item with a converted parent.
      $item_original = $item;
      while ($item && !isset($_SESSION['menu_item_map'][$item['pid']])) {
        $item = db_fetch_array(db_query('SELECT * FROM {menu} WHERE mid = %d', $item['pid']));
      }
      // This can only occur if the menu entry is a leftover in the menu table.
      // These do not appear in Drupal 5 anyways, so we skip them.
      if (!$item) {
        db_query('UPDATE {menu} SET converted = %d WHERE mid = %d', 1, $item_original['mid']);
        $_SESSION['system_update_6021']++;
        continue;
      }
    }
    // We need to recheck because item might have changed.
    if ($item['pid']) {
      // Fill the new fields.
      $item['link_title'] = $item['title'];
      $item['link_path'] = drupal_get_normal_path($item['path']);
      // We know the parent is already set. If it's not FALSE then it's an item.
      if ($_SESSION['menu_item_map'][$item['pid']]) {
        // The new menu system parent link id.
        $item['plid'] = $_SESSION['menu_item_map'][$item['pid']]['mlid'];
        // The new menu system menu name.
        $item['menu_name'] = $_SESSION['menu_item_map'][$item['pid']]['menu_name'];
      }
      else {
        // This a top level element.
        $item['plid'] = 0;
        // The menu name is stored among the menus.
        $item['menu_name'] = $_SESSION['menu_menu_map'][$item['pid']];
      }
      // Is the element visible in the menu block?
      $item['hidden'] = !($item['type'] & MENU_VISIBLE_IN_TREE);
      // Is it a custom(ized) element?
      if ($item['type'] & (MENU_CREATED_BY_ADMIN | MENU_MODIFIED_BY_ADMIN)) {
        $item['customized'] = TRUE;
      }
      // Items created via the menu module need to be assigned to it.
      if ($item['type'] & MENU_CREATED_BY_ADMIN) {
        $item['module'] = 'menu';
        $item['router_path'] = '';
        $item['updated'] = TRUE;
      }
      else {
        $item['module'] = 'system';
        $item['router_path'] = $item['path'];
        $item['updated'] = FALSE;
      }
      if ($item['description']) {
        $item['options']['attributes']['title'] = $item['description'];
      }      
      
      // Save the link.
      menu_link_save($item);
      $_SESSION['menu_item_map'][$item['mid']] = array('mlid' => $item['mlid'], 'menu_name' => $item['menu_name']);
    }
    elseif (!isset($_SESSION['menu_menu_map'][$item['mid']])) {
      $item['menu_name'] = 'menu-'. preg_replace('/[^a-zA-Z0-9]/', '-', strtolower($item['title']));
      $item['menu_name'] = substr($item['menu_name'], 0, 20);
      $original_menu_name = $item['menu_name'];
      $i = 0;
      while (db_result(db_query("SELECT menu_name FROM {menu_custom} WHERE menu_name = '%s'", $item['menu_name']))) {
        $item['menu_name'] = $original_menu_name . ($i++);
      }
      if ($item['path']) {
        // Another bunch of bogus entries. Apparently, these are leftovers
        // from Drupal 4.7 .
        $_SESSION['menu_bogus_menus'][] = $item['menu_name'];
      }
      else {
        // Add this menu to the list of custom menus.
        db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '')", $item['menu_name'], $item['title']);
      }
      $_SESSION['menu_menu_map'][$item['mid']] = $item['menu_name'];
      $_SESSION['menu_item_map'][$item['mid']] = FALSE;
    }
    db_query('UPDATE {menu} SET converted = %d WHERE mid = %d', 1, $item['mid']);
    $_SESSION['system_update_6021']++;
  }

  if ($_SESSION['system_update_6021'] >= $_SESSION['system_update_6021_max']) {
    if (!empty($_SESSION['menu_bogus_menus'])) {
      // Remove entries in bogus menus. This is secure because we deleted
      // every non-alpanumeric character from the menu name.
      $ret[] = update_sql("DELETE FROM {menu_links} WHERE menu_name IN ('". implode("', '", $_SESSION['menu_bogus_menus']) ."')");
    }

    $menu_primary_menu = variable_get('menu_primary_menu', 0);
    // Ensure that we wind up with a system menu named 'primary-links'.
    if (isset($_SESSION['menu_menu_map'][2])) {
      // The primary links menu that ships with Drupal 5 has mid = 2.  If this
      // menu hasn't been deleted by the site admin, we use that.
      $updated_primary_links_menu = 2;
    }
    elseif (isset($_SESSION['menu_menu_map'][$menu_primary_menu]) && $menu_primary_menu > 1) {
      // Otherwise, we use the menu that is currently assigned to the primary
      // links region of the theme, as long as it exists and isn't the
      // Navigation menu.
      $updated_primary_links_menu = $menu_primary_menu;
    }
    else {
      // As a last resort, create 'primary-links' as a new menu.
      $updated_primary_links_menu = 0;
      db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", $menus['primary-links']);
    }

    if ($updated_primary_links_menu) {
      // Change the existing menu name to 'primary-links'.
      $replace = array('%new_name' => 'primary-links', '%desc' => $menus['primary-links']['description'], '%old_name' => $_SESSION['menu_menu_map'][$updated_primary_links_menu]);
      $ret[] = update_sql(strtr("UPDATE {menu_custom} SET menu_name = '%new_name', description = '%desc' WHERE menu_name = '%old_name'", $replace));
      $ret[] = update_sql("UPDATE {menu_links} SET menu_name = 'primary-links' WHERE menu_name = '". $_SESSION['menu_menu_map'][$updated_primary_links_menu] ."'");
      $_SESSION['menu_menu_map'][$updated_primary_links_menu] = 'primary-links';
    }

    $menu_secondary_menu = variable_get('menu_secondary_menu', 0);
    // Ensure that we wind up with a system menu named 'secondary-links'.
    if (isset($_SESSION['menu_menu_map'][$menu_secondary_menu]) && $menu_secondary_menu > 1 && $menu_secondary_menu != $updated_primary_links_menu) {
      // We use the menu that is currently assigned to the secondary links
      // region of the theme, as long as (a) it exists, (b) it isn't the
      // Navigation menu, (c) it isn't the same menu we assigned as the
      // system 'primary-links' menu above, and (d) it isn't the same menu
      // assigned to the primary links region of the theme.
      $updated_secondary_links_menu = $menu_secondary_menu;
    }
    else {
      // Otherwise, create 'secondary-links' as a new menu.
      $updated_secondary_links_menu = 0;
      db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", $menus['secondary-links']);
    }

    if ($updated_secondary_links_menu) {
      // Change the existing menu name to 'secondary-links'.
      $replace = array('%new_name' => 'secondary-links', '%desc' => $menus['secondary-links']['description'], '%old_name' => $_SESSION['menu_menu_map'][$updated_secondary_links_menu]);
      $ret[] = update_sql(strtr("UPDATE {menu_custom} SET menu_name = '%new_name', description = '%desc' WHERE menu_name = '%old_name'", $replace));
      $ret[] = update_sql("UPDATE {menu_links} SET menu_name = 'secondary-links' WHERE menu_name = '". $_SESSION['menu_menu_map'][$updated_secondary_links_menu] ."'");
      $_SESSION['menu_menu_map'][$updated_secondary_links_menu] = 'secondary-links';
    }

    // Update menu OTF preferences.
    $mid = variable_get('menu_parent_items', 0);
    $menu_name = ($mid && isset($_SESSION['menu_menu_map'][$mid])) ? $_SESSION['menu_menu_map'][$mid] : 'navigation';
    variable_set('menu_default_node_menu', $menu_name);
    variable_del('menu_parent_items');

    // Update the source of the primary and secondary links.
    $menu_name = ($menu_primary_menu && isset($_SESSION['menu_menu_map'][$menu_primary_menu])) ? $_SESSION['menu_menu_map'][$menu_primary_menu] : '';
    variable_set('menu_primary_links_source', $menu_name);
    variable_del('menu_primary_menu');

    $menu_name = ($menu_secondary_menu && isset($_SESSION['menu_menu_map'][$menu_secondary_menu])) ? $_SESSION['menu_menu_map'][$menu_secondary_menu] : '';
    variable_set('menu_secondary_links_source', $menu_name);
    variable_del('menu_secondary_menu');

    // Skip the navigation menu - it is handled by the user module.
    unset($_SESSION['menu_menu_map'][1]);
    // Update the deltas for all menu module blocks.
    foreach ($_SESSION['menu_menu_map'] as $mid => $menu_name) {
      // This is again secure because we deleted every non-alpanumeric
      // character from the menu name.
      $ret[] = update_sql("UPDATE {blocks} SET delta = '". $menu_name ."' WHERE module = 'menu' AND delta = '". $mid ."'");
      $ret[] = update_sql("UPDATE {blocks_roles} SET delta = '". $menu_name ."' WHERE module = 'menu' AND delta = '". $mid ."'");
    }
    $ret[] = array('success' => TRUE, 'query' => 'Relocated '. $_SESSION['system_update_6021'] .' existing items to the new menu system.');
    $ret[] = update_sql("DROP TABLE {menu}");
    unset($_SESSION['system_update_6021'], $_SESSION['system_update_6021_max'], $_SESSION['menu_menu_map'], $_SESSION['menu_item_map'], $_SESSION['menu_bogus_menus']);
    // Create the menu overview links - also calls menu_rebuild(). If menu is
    // disabled, then just call menu_rebuild.
    if (function_exists('menu_enable')) {
      menu_enable();
    }
    else {
      menu_rebuild();
    }
    $ret['#finished'] = 1;
  }
  else {
    $ret['#finished'] = $_SESSION['system_update_6021'] / $_SESSION['system_update_6021_max'];
  }
  return $ret;
}

/**
 * Update files tables to associate files to a uid by default instead of a nid.
 * Rename file_revisions to upload since it should only be used by the upload
 * module used by upload to link files to nodes.
 */
function system_update_6022() {
  $ret = array();

  // Rename the nid field to vid, add status and timestamp fields, and indexes.
  db_drop_index($ret, 'files', 'nid');
  db_change_field($ret, 'files', 'nid', 'uid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_add_field($ret, 'files', 'status', array('type' => 'int', 'not null' => TRUE, 'default' => 0));
  db_add_field($ret, 'files', 'timestamp', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_add_index($ret, 'files', 'uid', array('uid'));
  db_add_index($ret, 'files', 'status', array('status'));
  db_add_index($ret, 'files', 'timestamp', array('timestamp'));

  // Rename the file_revisions table to upload then add nid column. Since we're
  // changing the table name we need to drop and re-add the indexes and
  // the primary key so both mysql and pgsql end up with the correct index
  // names.
  db_drop_primary_key($ret, 'file_revisions');
  db_drop_index($ret, 'file_revisions', 'vid');
  db_rename_table($ret, 'file_revisions', 'upload');
  db_add_field($ret, 'upload', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_add_index($ret, 'upload', 'nid', array('nid'));
  db_add_primary_key($ret, 'upload', array('vid', 'fid'));
  db_add_index($ret, 'upload', 'fid', array('fid'));

  // The nid column was renamed to uid. Use the old nid to find the node's uid.
  update_sql('UPDATE {files} SET uid = (SELECT n.uid FROM {node} n WHERE {files}.uid = n.nid)');
  update_sql('UPDATE {upload} SET nid = (SELECT r.nid FROM {node_revisions} r WHERE {upload}.vid = r.vid)');

  // Mark all existing files as FILE_STATUS_PERMANENT.
  $ret[] = update_sql('UPDATE {files} SET status = 1');

  return $ret;
}

function system_update_6023() {
  $ret = array();

  // nid is DEFAULT 0
  db_drop_index($ret, 'node_revisions', 'nid');
  db_change_field($ret, 'node_revisions', 'nid', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_add_index($ret, 'node_revisions', 'nid', array('nid'));
  return $ret;
}

/**
 * Add translation fields to nodes used by translation module.
 */
function system_update_6024() {
  $ret = array();
  db_add_field($ret, 'node', 'tnid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_add_field($ret, 'node', 'translate', array('type' => 'int', 'not null' => TRUE, 'default' => 0));
  db_add_index($ret, 'node', 'tnid', array('tnid'));
  db_add_index($ret, 'node', 'translate', array('translate'));
  return $ret;
}

/**
 * Increase the maximum length of node titles from 128 to 255.
 */
function system_update_6025() {
  $ret = array();
  db_drop_index($ret, 'node', 'node_title_type');
  db_change_field($ret, 'node', 'title', 'title', array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''));
  db_add_index($ret, 'node', 'node_title_type', array('title', array('type', 4)));
  db_change_field($ret, 'node_revisions', 'title', 'title', array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''));
  return $ret;
}

/**
 * Display warning about new Update status module.
 */
function system_update_6026() {
  $ret = array();

  // Notify user that new update module exists.
  drupal_set_message('Drupal can check periodically for important bug fixes and security releases using the new update status module. This module can be turned on from the <a href="'. url('admin/build/modules') .'">modules administration page</a>. For more information please read the <a href="http://drupal.org/handbook/modules/update">Update status handbook page</a>.');

  return $ret;
}

/**
 * Add block cache.
 */
function system_update_6027() {
  $ret = array();

  // Create the blocks.cache column.
  db_add_field($ret, 'blocks', 'cache', array('type' => 'int', 'not null' => TRUE, 'default' => 1, 'size' => 'tiny'));

  // The cache_block table is created in update_fix_d6_requirements() since
  // calls to cache_clear_all() would otherwise cause warnings.

  // Fill in the values for the new 'cache' column in the {blocks} table.
  foreach (module_list() as $module) {
    if ($module_blocks = module_invoke($module, 'block', 'list')) {
      foreach ($module_blocks as $delta => $block) {
        if (isset($block['cache'])) {
          db_query("UPDATE {blocks} SET cache = %d WHERE module = '%s' AND delta = '%s'", $block['cache'], $module, $delta);
        }
      }
    }
  }

  return $ret;
}

/**
 * Add the node load cache table.
 */
function system_update_6028() {
  // Removed node_load cache to discuss it more for Drupal 7.
  return array();
}

/**
 * Enable the dblog module on sites that upgrade, since otherwise
 * watchdog logging will stop unexpectedly.
 */
function system_update_6029() {
  // The watchdog table is now owned by dblog, which is not yet
  // "installed" according to the system table, but the table already
  // exists.  We set the module as "installed" here to avoid an error
  // later.
  //
  // Although not the case for the initial D6 release, it is likely
  // that dblog.install will have its own update functions eventually.
  // However, dblog did not exist in D5 and this update is part of the
  // initial D6 release, so we know that dblog is not installed yet.
  // It is therefore correct to install it as version 0.  If
  // dblog updates exist, the next run of update.php will get them.
  drupal_set_installed_schema_version('dblog', 0);
  module_enable(array('dblog'));
  menu_rebuild();
  return array(array('success' => TRUE, 'query' => "'dblog' module enabled."));
}

/**
 * Add the tables required by actions.inc.
 */
function system_update_6030() {
  $ret = array();

  // Rename the old contrib actions table if it exists so the contrib version
  // of the module can do something with the old data.
  if (db_table_exists('actions')) {
    db_rename_table($ret, 'actions', 'actions_old_contrib');
  }

  $schema['actions'] = array(
    'fields' => array(
      'aid' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => '0'),
      'type' => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'callback' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'parameters' => array('type' => 'text', 'not null' => TRUE, 'size' => 'big'),
      'description' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => '0'),
    ),
    'primary key' => array('aid'),
  );

  $schema['actions_aid'] = array(
    'fields' => array(
      'aid' => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE),
    ),
    'primary key' => array('aid'),
  );

  db_create_table($ret, 'actions', $schema['actions']);
  db_create_table($ret, 'actions_aid', $schema['actions_aid']);

  return $ret;
}

/**
 * Ensure that installer cannot be run again after updating from Drupal 5.x to 6.x
 * Actually, this is already done by system_update_6014(), so this is now a no-op.
 */
function system_update_6031() {
  return array();
}

/**
 * profile_fields.name used to be nullable but is part of a unique key
 * and so shouldn't be.
 */
function system_update_6032() {
  $ret = array();
  if (db_table_exists('profile_fields')) {
    db_drop_unique_key($ret, 'profile_fields', 'name');
    db_change_field($ret, 'profile_fields', 'name', 'name', array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''));
    db_add_unique_key($ret, 'profile_fields', 'name', array('name'));
  }
  return $ret;
}

/**
 * Change node_comment_statistics to be not autoincrement.
 */
function system_update_6033() {
  $ret = array();
  if (db_table_exists('node_comment_statistics')) {
    // On pgsql but not mysql, db_change_field() drops all keys
    // involving the changed field, which in this case is the primary
    // key.  The normal approach is explicitly drop the pkey, change the
    // field, and re-create the pkey.
    //
    // Unfortunately, in this case that won't work on mysql; we CANNOT
    // drop the pkey because on mysql auto-increment fields must be
    // included in at least one key or index.
    //
    // Since we cannot drop the pkey before db_change_field(), after
    // db_change_field() we may or may not still have a pkey.  The
    // simple way out is to re-create the pkey only when using pgsql.
    // Realistic requirements trump idealistic purity.
    db_change_field($ret, 'node_comment_statistics', 'nid', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
    if ($GLOBALS['db_type'] == 'pgsql') {
      db_add_primary_key($ret, 'node_comment_statistics', array('nid'));
    }
  }
  return $ret;
}

/**
 * Rename permission "administer access control" to "administer permissions".
 */
function system_update_6034() {
  $ret = array();
  $result = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");
  while ($role = db_fetch_object($result)) {
    $renamed_permission = preg_replace('/administer access control/', 'administer permissions', $role->perm);
    if ($renamed_permission != $role->perm) {
      $ret[] = update_sql("UPDATE {permission} SET perm = '$renamed_permission' WHERE rid = $role->rid");
    }
  }
  return $ret;
}

/**
 * Change index on system table for better performance.
 */
function system_update_6035() {
  $ret = array();
  db_drop_index($ret, 'system', 'weight');
  db_add_index($ret, 'system', 'modules', array(array('type', 12), 'status', 'weight', 'filename'));
  db_add_index($ret, 'system', 'bootstrap', array(array('type', 12), 'status', 'bootstrap', 'weight', 'filename'));
  return $ret;
}

/**
 * Change the search schema and indexing.
 *
 * The table data is preserved where possible in MYSQL and MYSQLi using
 * ALTER IGNORE. Other databases don't support that, so for them the
 * tables are dropped and re-created, and will need to be re-indexed
 * from scratch.
 */
function system_update_6036() {
  $ret = array();
  if (db_table_exists('search_index')) {
    // Create the search_dataset.reindex column.
    db_add_field($ret, 'search_dataset', 'reindex', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));

    // Drop the search_index.from fields which are no longer used.
    db_drop_index($ret, 'search_index', 'from_sid_type');
    db_drop_field($ret, 'search_index', 'fromsid');
    db_drop_field($ret, 'search_index', 'fromtype');

    // Drop the search_dataset.sid_type index, so that it can be made unique.
    db_drop_index($ret, 'search_dataset', 'sid_type');

    // Create the search_node_links Table.
    $search_node_links_schema = array(
      'fields' => array(
        'sid'      => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
        'type'     => array('type' => 'varchar', 'length' => 16, 'not null' => TRUE, 'default' => ''),
        'nid'      => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
        'caption'    => array('type' => 'text', 'size' => 'big', 'not null' => FALSE),
      ),
      'primary key' => array('sid', 'type', 'nid'),
      'indexes' => array('nid' => array('nid')),
    );
    db_create_table($ret, 'search_node_links', $search_node_links_schema);

    // with the change to search_dataset.reindex, the search queue is handled differently,
    // and this is no longer needed
    variable_del('node_cron_last');

    // Add a unique index for the search_index.
    if ($GLOBALS['db_type'] == 'mysql' || $GLOBALS['db_type'] == 'mysqli') {
      // Since it's possible that some existing sites have duplicates,
      // create the index using the IGNORE keyword, which ignores duplicate errors.
      // However, pgsql doesn't support it
      $ret[] = update_sql("ALTER IGNORE TABLE {search_index} ADD UNIQUE KEY word_sid_type (word, sid, type)");
      $ret[] = update_sql("ALTER IGNORE TABLE {search_dataset} ADD UNIQUE KEY sid_type (sid, type)");

      // Everything needs to be reindexed.
      $ret[] = update_sql("UPDATE {search_dataset} SET reindex = 1");
    }
    else {
      // Delete the existing tables if there are duplicate values
      if (db_result(db_query("SELECT sid FROM {search_dataset} GROUP BY sid, type HAVING COUNT(*) > 1")) || db_result(db_query("SELECT sid FROM {search_index} GROUP BY word, sid, type HAVING COUNT(*) > 1"))) {
        $ret[] = update_sql('DELETE FROM {search_dataset}');
        $ret[] = update_sql('DELETE FROM {search_index}');
        $ret[] = update_sql('DELETE FROM {search_total}');
      }
      else {
        // Everything needs to be reindexed.
        $ret[] = update_sql("UPDATE {search_dataset} SET reindex = 1");
      }

      // create the new indexes
      db_add_unique_key($ret, 'search_index', 'word_sid_type', array('word', 'sid', 'type'));
      db_add_unique_key($ret, 'search_dataset', 'sid_type', array('sid', 'type'));
    }
  }
  return $ret;
}

/**
 * Create consistent empty region for disabled blocks.
 */
function system_update_6037() {
  $ret = array();
  db_change_field($ret, 'blocks', 'region', 'region', array('type' => 'varchar', 'length' => 64, 'not null' => TRUE, 'default' => ''));
  $ret[] = update_sql("UPDATE {blocks} SET region = '' WHERE status = 0");
  return $ret;
}

/**
 * Ensure that "Account" is not used as a Profile category.
 */
function system_update_6038() {
  $ret = array();
  if (db_table_exists('profile_fields')) {
    $ret[] = update_sql("UPDATE {profile_fields} SET category = 'Account settings' WHERE LOWER(category) = 'account'");
    if ($affectedrows = db_affected_rows()) {
      drupal_set_message('There were '. $affectedrows .' profile fields that used a reserved category name. They have been assigned to the category "Account settings".');
    }
  }
  return $ret;
}

/**
 * Rename permissions "edit foo content" to "edit any foo content".
 * Also update poll module permission "create polls" to "create
 * poll content".
 */
function system_update_6039() {
  $ret = array();
  $result = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");
  while ($role = db_fetch_object($result)) {
    $renamed_permission = preg_replace('/(?<=^|,\ )edit\ ([a-zA-Z0-9_\-]+)\ content(?=,|$)/', 'edit any $1 content', $role->perm);
    $renamed_permission = preg_replace('/(?<=^|,\ )create\ polls(?=,|$)/', 'create poll content', $renamed_permission);
    if ($renamed_permission != $role->perm) {
      $ret[] = update_sql("UPDATE {permission} SET perm = '$renamed_permission' WHERE rid = $role->rid");
    }
  }
  return $ret;
}

/**
 * Add a weight column to the upload table.
 */
function system_update_6040() {
  $ret = array();
  if (db_table_exists('upload')) {
    db_add_field($ret, 'upload', 'weight', array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'tiny'));
  }
  return $ret;
}

/**
 * Change forum vocabulary not to be required by default and set the weight of the forum.module 1 higher than the taxonomy.module.
 */
function system_update_6041() {
  $weight = intval((db_result(db_query("SELECT weight FROM {system} WHERE name = 'taxonomy'"))) + 1);
  $ret = array();
  $vid = intval(variable_get('forum_nav_vocabulary', ''));
  if (db_table_exists('vocabulary') && $vid) {
    $ret[] = update_sql("UPDATE {vocabulary} SET required = 0 WHERE vid = " . $vid);
    $ret[] = update_sql("UPDATE {system} SET weight = ". $weight ." WHERE name = 'forum'");
  }
  return $ret;
}

/**
 * Upgrade recolored theme stylesheets to new array structure.
 */
function system_update_6042() {
  foreach (list_themes() as $theme) {
    $stylesheet = variable_get('color_'. $theme->name .'_stylesheet', NULL);
    if (!empty($stylesheet)) {
      variable_set('color_'. $theme->name .'_stylesheets', array($stylesheet));
      variable_del('color_'. $theme->name .'_stylesheet');
    }
  }
  return array();
}

/**
 * Update table indices to make them more rational and useful.
 */
function system_update_6043() {
  $ret = array();
  // Required modules first.
  // Add new system module indexes.
  db_add_index($ret, 'flood', 'allow', array('event', 'hostname', 'timestamp'));
  db_add_index($ret, 'history', 'nid', array('nid'));
  // Change length of theme field in {blocks} to be consistent with module, and
  // to avoid a MySQL error regarding a too-long index.  Also add new indices.
  db_change_field($ret, 'blocks', 'theme', 'theme', array('type' => 'varchar', 'length' => 64, 'not null' => TRUE, 'default' => ''),array(
                  'unique keys' => array('tmd' => array('theme', 'module', 'delta'),),
                  'indexes' => array('list' => array('theme', 'status', 'region', 'weight', 'module'),),));
  db_add_index($ret, 'blocks_roles', 'rid', array('rid'));
  // Improve filter module indices.
  db_drop_index($ret, 'filters', 'weight');
  db_add_unique_key($ret, 'filters', 'fmd', array('format', 'module', 'delta'));
  db_add_index($ret, 'filters', 'list', array('format', 'weight', 'module', 'delta'));
  // Drop unneeded keys form the node table.
  db_drop_index($ret, 'node', 'status');
  db_drop_unique_key($ret, 'node', 'nid_vid');
  // Improve user module indices.
  db_add_index($ret, 'users', 'mail', array('mail'));
  db_add_index($ret, 'users_roles', 'rid', array('rid'));

  // Optional modules - need to check if the tables exist.
  // Alter aggregator module's tables primary keys to make them more useful.
  if (db_table_exists('aggregator_category_feed')) {
    db_drop_primary_key($ret, 'aggregator_category_feed');
    db_add_primary_key($ret, 'aggregator_category_feed', array('cid', 'fid'));
    db_add_index($ret, 'aggregator_category_feed', 'fid', array('fid'));
  }
  if (db_table_exists('aggregator_category_item')) {
    db_drop_primary_key($ret, 'aggregator_category_item');
    db_add_primary_key($ret, 'aggregator_category_item', array('cid', 'iid'));
    db_add_index($ret, 'aggregator_category_item', 'iid', array('iid'));
  }
  // Alter contact module's table to add an index.
  if (db_table_exists('contact')) {
    db_add_index($ret, 'contact', 'list', array('weight', 'category'));
  }
  // Alter locale table to add a primary key, drop an index.
  if (db_table_exists('locales_target')) {
    db_add_primary_key($ret, 'locales_target', array('language', 'lid', 'plural'));
  }
  // Alter a poll module table to add a primary key.
  if (db_table_exists('poll_votes')) {
    db_drop_index($ret, 'poll_votes', 'nid');
    db_add_primary_key($ret, 'poll_votes', array('nid', 'uid', 'hostname'));
  }
  // Alter a profile module table to add a primary key.
  if (db_table_exists('profile_values')) {
    db_drop_index($ret, 'profile_values', 'uid');
    db_drop_index($ret, 'profile_values', 'fid');
    db_change_field($ret,'profile_values' ,'fid', 'fid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0,), array('indexes' => array('fid' => array('fid'),)));
    db_change_field($ret,'profile_values' ,'uid', 'uid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0,));
    db_add_primary_key($ret, 'profile_values', array('uid', 'fid'));
  }
  // Alter a statistics module table to add an index.
  if (db_table_exists('accesslog')) {
    db_add_index($ret, 'accesslog', 'uid', array('uid'));
  }
  // Alter taxonomy module's tables.
  if (db_table_exists('term_data')) {
    db_drop_index($ret, 'term_data', 'vid');
    db_add_index($ret, 'term_data', 'vid_name', array('vid', 'name'));
    db_add_index($ret, 'term_data', 'taxonomy_tree', array('vid', 'weight', 'name'));
  }
  if (db_table_exists('term_node')) {
    db_drop_primary_key($ret, 'term_node');
    db_drop_index($ret, 'term_node', 'tid');
    db_add_primary_key($ret, 'term_node', array('tid', 'vid'));
  }
  if (db_table_exists('term_relation')) {
    db_drop_index($ret, 'term_relation', 'tid1');
    db_add_unique_key($ret, 'term_relation', 'tid1_tid2', array('tid1', 'tid2'));
  }
  if (db_table_exists('term_synonym')) {
    db_drop_index($ret, 'term_synonym', 'name');
    db_add_index($ret, 'term_synonym', 'name_tid', array('name', 'tid'));
  }
  if (db_table_exists('vocabulary')) {
    db_add_index($ret, 'vocabulary', 'list', array('weight', 'name'));
  }
  if (db_table_exists('vocabulary_node_types')) {
    db_drop_primary_key($ret, 'vocabulary_node_types');
    db_add_primary_key($ret, 'vocabulary_node_types', array('type', 'vid'));
    db_add_index($ret, 'vocabulary_node_types', 'vid', array('vid'));
  }
  // If we updated in RC1 or before ensure we don't update twice.
  variable_set('system_update_6043_RC2', TRUE);

  return $ret;
}

/**
 * RC1 to RC2 index cleanup.
 */
function system_update_6044() {
  $ret = array();

  // Delete invalid entries in {term_node} after system_update_6001.
  $ret[] = update_sql("DELETE FROM {term_node} WHERE vid = 0");

  // Only execute the rest of this function if 6043 was run in RC1 or before.
  if (variable_get('system_update_6043_RC2', FALSE)) {
    variable_del('system_update_6043_RC2');
    return $ret;
  }

  // User module indices.
  db_drop_unique_key($ret, 'users', 'mail');
  db_add_index($ret, 'users', 'mail', array('mail'));

  // Optional modules - need to check if the tables exist.
  // Alter taxonomy module's tables.
  if (db_table_exists('term_data')) {
    db_drop_unique_key($ret, 'term_data', 'vid_name');
    db_add_index($ret, 'term_data', 'vid_name', array('vid', 'name'));
  }
  if (db_table_exists('term_synonym')) {
    db_drop_unique_key($ret, 'term_synonym', 'name_tid', array('name', 'tid'));
    db_add_index($ret, 'term_synonym', 'name_tid', array('name', 'tid'));
  }

  return $ret;
}

/**
 * Update blog, book and locale module permissions.
 *
 * Blog module got "edit own blog" replaced with the more granular "create
 * blog entries", "edit own blog entries" and "delete own blog entries"
 * permissions. We grant create and edit to previously privileged users, but
 * delete is not granted to be in line with other permission changes in Drupal 6.
 *
 * Book module's "edit book pages" was upgraded to the bogus "edit book content"
 * in Drupal 6 RC1 instead of "edit any book content", which would be correct.
 *
 * Locale module introduced "administer languages" and "translate interface"
 * in place of "administer locales".
 *
 * Modeled after system_update_6039().
 */
function system_update_6045() {
  $ret = array();
  $result = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");
  while ($role = db_fetch_object($result)) {
    $renamed_permission = preg_replace('/(?<=^|,\ )edit\ own\ blog(?=,|$)/', 'create blog entries, edit own blog entries', $role->perm);
    $renamed_permission = preg_replace('/(?<=^|,\ )edit\ book\ content(?=,|$)/', 'edit any book content', $renamed_permission);
    $renamed_permission = preg_replace('/(?<=^|,\ )administer\ locales(?=,|$)/', 'administer languages, translate interface', $renamed_permission);
    if ($renamed_permission != $role->perm) {
      $ret[] = update_sql("UPDATE {permission} SET perm = '$renamed_permission' WHERE rid = $role->rid");
    }
  }

  // Notify user that delete permissions may have been changed. This was in
  // effect since system_update_6039(), but there was no user notice.
  drupal_set_message('Drupal now has separate edit and delete permissions. Previously, users who were able to edit content were automatically allowed to delete it. For added security, delete permissions for individual core content types have been <strong>removed</strong> from all roles on your site (only roles with the "administer nodes" permission can now delete these types of content). If you would like to reenable any individual delete permissions, you can do this at the <a href="'. url('admin/user/permissions', array('fragment' => 'module-node')) .'">permissions page</a>.');
  return $ret;
}

/**
 * Ensure that the file_directory_path variable is set (using the old 5.x
 * default, if necessary), so that the changed 6.x default won't break
 * existing sites.
 */
function system_update_6046() {
  $ret = array();
  if (!variable_get('file_directory_path', FALSE)) {
    variable_set('file_directory_path', 'files');
    $ret[] = array('success' => TRUE, 'query' => "variable_set('file_directory_path')");
  }
  return $ret;
}

/**
 * Fix cache mode for blocks inserted in system_install() in fresh installs of previous RC.
 */
function system_update_6047() {
  $ret = array();
  $ret[] = update_sql("UPDATE {blocks} SET cache = -1 WHERE module = 'user' AND delta IN ('0', '1')");
  $ret[] = update_sql("UPDATE {blocks} SET cache = -1 WHERE module = 'system' AND delta = '0'");
  return $ret;
}

/**
 * @} End of "defgroup updates-5.x-to-6.x".
 */

/**
 * @defgroup updates-6.x-extra Extra system updates for 6.x
 * @{
 */

/**
* Increase the size of the 'load_functions' and 'to_arg_functions' fields in table 'menu_router'.
*/
function system_update_6048() {
  $ret = array();
  db_change_field($ret, 'menu_router', 'load_functions', 'load_functions', array('type' => 'text', 'not null' => TRUE,));
  db_change_field($ret, 'menu_router', 'to_arg_functions', 'to_arg_functions', array('type' => 'text', 'not null' => TRUE,));

  return $ret;
}

/**
 * Replace src index on the {url_alias} table with src, language.
 */
function system_update_6049() {
  $ret = array();
  db_drop_index($ret, 'url_alias', 'src');
  db_add_index($ret, 'url_alias', 'src_language', array('src', 'language'));
  return $ret;
}

/**
 * Clear any menu router blobs stored in the cache table.
 */
function system_update_6050() {
  $ret = array();
  cache_clear_all('router:', 'cache_menu', TRUE);
  return $ret;
}

/**
 * Create a signature_format column.
 */
function system_update_6051() {
  $ret = array();

  if (!db_column_exists('users', 'signature_format')) {

    // Set future input formats to FILTER_FORMAT_DEFAULT to ensure a safe default
    // when incompatible modules insert into the users table. An actual format
    // will be assigned when users save their signature.

    $schema = array(
      'type' => 'int',
      'size' => 'small',
      'not null' => TRUE,
      'default' => FILTER_FORMAT_DEFAULT,
      'description' => 'The {filter_formats}.format of the signature.',
    );

    db_add_field($ret, 'users', 'signature_format', $schema);

    // Set the format of existing signatures to the current default input format.
    if ($current_default_filter = variable_get('filter_default_format', 0)) {
      $ret[] = update_sql("UPDATE {users} SET signature_format = ". $current_default_filter);
    }

    drupal_set_message("User signatures no longer inherit comment input formats. Each user's signature now has its own associated format that can be selected on the user's account page. Existing signatures have been set to your site's default input format.");
  }

  return $ret;
}

/**
 * Add a missing index on the {menu_router} table.
 */
function system_update_6052() {
  $ret = array();
  db_add_index($ret, 'menu_router', 'tab_root_weight_title', array(array('tab_root', 64), 'weight', 'title'));
  return $ret;
}

/**
 * Add a {system} index on type and name.
 */
function system_update_6053() {
  $ret = array();
  db_add_index($ret, 'system', 'type_name', array(array('type', 12), 'name'));
  return $ret;
}

/**
 * Add semaphore table.
 */
function system_update_6054() {
  $ret = array();

  // The table may have already been added by update_fix_d6_requirements(), so
  // check for its existence before creating.
  if (!db_table_exists('semaphore')) {
    $schema['semaphore'] = array(
      'fields' => array(
        'name' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => ''),
        'value' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => ''),
        'expire' => array(
          'type' => 'float',
          'size' => 'big',
          'not null' => TRUE),
        ),
      'indexes' => array('expire' => array('expire')),
      'primary key' => array('name'),
    );
    db_create_table($ret, 'semaphore', $schema['semaphore']);
  }

  return $ret;
}

/**
 * Improve indexes on the {url_alias} table.
 */
function system_update_6055() {
  $ret = array();
  db_drop_index($ret, 'url_alias', 'src_language');
  db_drop_unique_key($ret, 'url_alias', 'dst_language');
  db_add_index($ret, 'url_alias', 'src_language_pid', array('src', 'language', 'pid'));
  db_add_unique_key($ret, 'url_alias', 'dst_language_pid', array('dst', 'language', 'pid'));
  return $ret;
}

/**
 * Convert {session} data storage to blob.
 */
function system_update_6056() {
  $ret = array();
  db_change_field($ret, 'sessions', 'session', 'session', array('type' => 'blob', 'not null' => FALSE, 'size' => 'big'));
  return $ret;
}

/**
 * @} End of "defgroup updates-6.x-extra".
 * The next series of updates should start at 7000.
 */

