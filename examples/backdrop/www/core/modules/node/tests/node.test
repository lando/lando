<?php
/**
 * @file
 * Tests for node.module.
 */

/**
 * Defines a base class for testing the Node module.
 */
class NodeWebTestCase extends BackdropWebTestCase {
  function setUp() {
    $modules = func_get_args();
    if (isset($modules[0]) && is_array($modules[0])) {
      $modules = $modules[0];
    }
    $modules[] = 'node';
    parent::setUp($modules);

    // Create Page and Post node types.
    if ($this->profile != 'standard') {
      $this->backdropCreateContentType(array('type' => 'page', 'name' => 'Page'));
      $this->backdropCreateContentType(array('type' => 'post', 'name' => 'Post'));
    }
  }
}

/**
 * Tests the node_load_multiple() function.
 */
class NodeLoadMultipleUnitTest extends BackdropWebTestCase {
  protected $profile = 'testing';

  function setUp() {
    parent::setUp();

    // Create content types for testing.
    $this->backdropCreateContentType(array('type' => 'page', 'name' => 'Page'));
    $this->backdropCreateContentType(array('type' => 'post', 'name' => 'Post'));

    // Create and login web user.
    $web_user = $this->backdropCreateUser(array('create post content', 'create page content', 'access content'));
    $this->backdropLogin($web_user);
  }

  /**
   * Creates four nodes and ensures that they are loaded correctly.
   */
  function testNodeMultipleLoad() {
    $node1 = $this->backdropCreateNode(array('type' => 'post', 'promote' => 1));
    $node2 = $this->backdropCreateNode(array('type' => 'post', 'promote' => 1));
    $node3 = $this->backdropCreateNode(array('type' => 'post', 'promote' => 0));
    $node4 = $this->backdropCreateNode(array('type' => 'page', 'promote' => 0));

    // Confirm that promoted nodes appear in the default node listing.
    $this->backdropGet('node');
    $this->assertText($node1->title, 'Node title appears on the default listing.');
    $this->assertText($node2->title, 'Node title appears on the default listing.');
    $this->assertNoText($node3->title, 'Node title does not appear in the default listing.');
    $this->assertNoText($node4->title, 'Node title does not appear in the default listing.');

    // Load nodes with only a condition. Nodes 3 and 4 will be loaded.
    $nodes = node_load_multiple(NULL, array('promote' => 0));
    $this->assertEqual($node3->title, $nodes[$node3->nid]->title, 'Node was loaded.');
    $this->assertEqual($node4->title, $nodes[$node4->nid]->title, 'Node was loaded.');
    $count = count($nodes);
    $this->assertTrue($count == 2, format_string('@count nodes loaded.', array('@count' => $count)));

    // Load nodes by nid. Nodes 1, 2 and 4 will be loaded.
    $nodes = node_load_multiple(array(1, 2, 4));
    $count = count($nodes);
    $this->assertTrue(count($nodes) == 3, format_string('@count nodes loaded', array('@count' => $count)));
    $this->assertTrue(isset($nodes[$node1->nid]), 'Node is correctly keyed in the array');
    $this->assertTrue(isset($nodes[$node2->nid]), 'Node is correctly keyed in the array');
    $this->assertTrue(isset($nodes[$node4->nid]), 'Node is correctly keyed in the array');
    foreach ($nodes as $node) {
      $this->assertTrue(is_object($node), 'Node is an object');
    }

    // Load nodes by nid, where type = post. Nodes 1, 2 and 3 will be loaded.
    $nodes = node_load_multiple(array(1, 2, 3, 4), array('type' => 'post'));
    $count = count($nodes);
    $this->assertTrue($count == 3, format_string('@count nodes loaded', array('@count' => $count)));
    $this->assertEqual($nodes[$node1->nid]->title, $node1->title, 'Node successfully loaded.');
    $this->assertEqual($nodes[$node2->nid]->title, $node2->title, 'Node successfully loaded.');
    $this->assertEqual($nodes[$node3->nid]->title, $node3->title, 'Node successfully loaded.');
    $this->assertFalse(isset($nodes[$node4->nid]));

    // Now that all nodes have been loaded into the static cache, ensure that
    // they are loaded correctly again when a condition is passed.
    $nodes = node_load_multiple(array(1, 2, 3, 4), array('type' => 'post'));
    $count = count($nodes);
    $this->assertTrue($count == 3, format_string('@count nodes loaded.', array('@count' => $count)));
    $this->assertEqual($nodes[$node1->nid]->title, $node1->title, 'Node successfully loaded');
    $this->assertEqual($nodes[$node2->nid]->title, $node2->title, 'Node successfully loaded');
    $this->assertEqual($nodes[$node3->nid]->title, $node3->title, 'Node successfully loaded');
    $this->assertFalse(isset($nodes[$node4->nid]), 'Node was not loaded');

    // Load nodes by nid, where type = post and promote = 0.
    $nodes = node_load_multiple(array(1, 2, 3, 4), array('type' => 'post', 'promote' => 0));
    $count = count($nodes);
    $this->assertTrue($count == 1, format_string('@count node loaded', array('@count' => $count)));
    $this->assertEqual($nodes[$node3->nid]->title, $node3->title, 'Node successfully loaded.');
  }
}

/**
 * Tests for the hooks invoked during node_load().
 */
class NodeLoadHooksTestCase extends BackdropWebTestCase {
  protected $profile = 'testing';

  function setUp() {
    parent::setUp('node_test');
    // Create content types for testing.
    $this->backdropCreateContentType(array('type' => 'page', 'name' => 'Page'));
    $this->backdropCreateContentType(array('type' => 'post', 'name' => 'Post'));
  }

  /**
   * Tests that hook_node_load() is invoked correctly.
   */
  function testHookNodeLoad() {
    // Create some sample posts and pages.
    $node1 = $this->backdropCreateNode(array('type' => 'post', 'status' => NODE_PUBLISHED));
    $node2 = $this->backdropCreateNode(array('type' => 'post', 'status' => NODE_PUBLISHED));
    $node3 = $this->backdropCreateNode(array('type' => 'post', 'status' => NODE_NOT_PUBLISHED));
    $node4 = $this->backdropCreateNode(array('type' => 'page', 'status' => NODE_NOT_PUBLISHED));

    // Check that when a set of nodes that only contains posts is loaded,
    // the properties added to the node by node_test_node_load() correctly
    // reflect the expected values.
    $nodes = node_load_multiple(array(), array('status' => NODE_PUBLISHED));
    $loaded_node = end($nodes);
    $this->assertEqual($loaded_node->node_test_loaded_nids, array($node1->nid, $node2->nid), 'hook_node_load() received the correct list of node IDs the first time it was called.');
    $this->assertEqual($loaded_node->node_test_loaded_types, array('post'), 'hook_node_load() received the correct list of node types the first time it was called.');

    // Now, as part of the same page request, load a set of nodes that contain
    // both posts and pages, and make sure the parameters passed to
    // node_test_node_load() are correctly updated.
    $nodes = node_load_multiple(array(), array('status' => NODE_NOT_PUBLISHED));
    $loaded_node = end($nodes);
    $this->assertEqual($loaded_node->node_test_loaded_nids, array($node4->nid, $node3->nid), 'hook_node_load() received the correct list of node IDs the second time it was called.');
    $this->assertEqual($loaded_node->node_test_loaded_types, array('page', 'post'), 'hook_node_load() received the correct list of node types the second time it was called.');
  }
}

/**
 * Tests the node revision functionality.
 */
class NodeRevisionsTestCase extends BackdropWebTestCase {

  /**
   * Nodes used by the test.
   *
   * @var array
   */
  protected $nodes;

  /**
   * The revision messages for node revisions created in the test.
   *
   * @var array
   */
  protected $logs;

  function setUp() {
    parent::setUp();

    // Make sure we're using UTC
    date_default_timezone_set('UTC');

    // Create and login user.
    $web_user = $this->backdropCreateUser(array(
      'view revisions',
      'revert revisions',
      'edit any page content',
      'delete revisions',
      'delete any page content',
    ));
    $this->backdropLogin($web_user);

    // Create initial node.
    $node = $this->backdropCreateNode();
    $settings = get_object_vars($node);
    $settings['revision'] = 1;

    $nodes = array();
    $logs = array();

    // Get original node.
    $nodes[] = $node;

    // Create three revisions.
    $revision_count = 3;
    for ($i = 0; $i < $revision_count; $i++) {
      $logs[] = $settings['log'] = $this->randomName(32);

      // Create revision with random title and body and update variables.
      $this->backdropCreateNode($settings);
      // Make sure we get revision information.
      $node = node_load($node->nid);
      $settings = get_object_vars($node);

      $nodes[] = $node;
    }

    $this->nodes = $nodes;
    $this->logs = $logs;
  }

  /**
   * Checks node revision related operations.
   */
  function testRevisions() {
    $nodes = $this->nodes;
    $logs = $this->logs;

    // Get last node for simple checks.
    $node = $nodes[3];

    // Confirm the correct revision text appears on "view revisions" page.
    $this->backdropGet("node/$node->nid/revisions/$node->vid/view");
    $this->assertText($node->body[LANGUAGE_NONE][0]['value'], 'Correct text displays for version.');

    // Confirm the correct log message appears on "revisions overview" page.
    $this->backdropGet("node/$node->nid/revisions");
    foreach ($logs as $log) {
      $this->assertText($log, t('Log message found.'));
    }

    // Confirm that revisions revert properly.
    $this->backdropPost("node/$node->nid/revisions/{$nodes[1]->vid}/revert", array(), t('Revert'));
    $this->assertRaw(t('@type %title has been reverted back to the revision from %revision-date.', array(
      '@type' => 'Page',
      '%title' => $nodes[1]->title,
      '%revision-date' => format_date($nodes[1]->revision_timestamp),
    )), 'Revision reverted.');
    $reverted_node = node_load($node->nid);
    $this->assertTrue(($nodes[1]->body[LANGUAGE_NONE][0]['value'] == $reverted_node->body[LANGUAGE_NONE][0]['value']), 'Node reverted correctly.');

    // Confirm revisions delete properly.
    $this->backdropPost("node/$node->nid/revisions/{$nodes[1]->vid}/delete", array(), t('Delete'));
    $this->assertRaw(t('Revision from %revision-date of @type %title has been deleted.', array(
      '%revision-date' => format_date($nodes[1]->revision_timestamp),
      '@type' => 'Page',
      '%title' => $nodes[1]->title,
    )), 'Revision deleted.');
    $this->assertTrue(db_query('SELECT COUNT(vid) FROM {node_revision} WHERE nid = :nid and vid = :vid', array(':nid' => $node->nid, ':vid' => $nodes[1]->vid))->fetchField() == 0, 'Revision not found.');

    // Set the revision timestamp to an older date to make sure that the
    // confirmation message correctly displays the stored revision date.
    $old_revision_date = REQUEST_TIME - 86400;
    db_update('node_revision')
      ->condition('vid', $nodes[2]->vid)
      ->fields(array(
        'timestamp' => $old_revision_date,
      ))
      ->execute();
    $this->backdropPost("node/$node->nid/revisions/{$nodes[2]->vid}/revert", array(), t('Revert'));
    $this->assertRaw(t('@type %title has been reverted back to the revision from %revision-date.', array(
      '@type' => 'Page',
      '%title' => $nodes[2]->title,
      '%revision-date' => format_date($old_revision_date),
    )));
  }

  /**
   * Checks that revisions are correctly saved without log messages.
   */
  function testNodeRevisionWithoutLogMessage() {
    // Create a node with an initial log message.
    $log = $this->randomName(10);
    $node = $this->backdropCreateNode(array('log' => $log));

    // Save over the same revision and explicitly provide an empty log message
    // (for example, to mimic the case of a node form submitted with no text in
    // the "log message" field), and check that the original log message is
    // preserved.
    $new_title = $this->randomName(10) . 'testNodeRevisionWithoutLogMessage1';

    $node = clone $node;
    $node->title = $new_title;
    $node->log = '';
    $node->revision = FALSE;

    $node->save();
    $this->backdropGet('node/' . $node->nid);
    $this->assertText($new_title, 'New node title appears on the page.');
    $node_revision = node_load($node->nid, NULL, TRUE);
    $this->assertEqual($node_revision->log, $log, 'After an existing node revision is re-saved without a log message, the original log message is preserved.');

    // Create another node with an initial log message.
    $node = $this->backdropCreateNode(array('log' => $log));

    // Save a new node revision without providing a log message, and check that
    // this revision has an empty log message.
    $new_title = $this->randomName(10) . 'testNodeRevisionWithoutLogMessage2';

    $node = clone $node;
    $node->title = $new_title;
    $node->revision = TRUE;
    $node->log = NULL;

    $node->save();
    $this->backdropGet('node/' . $node->nid);
    $this->assertText($new_title, 'New node title appears on the page.');
    $node_revision = node_load($node->nid, NULL, TRUE);
    $this->assertTrue(empty($node_revision->log), 'After a new node revision is saved with an empty log message, the log message for the node is empty.');
  }
}

/**
 * Tests the node edit functionality.
 */
class PageEditTestCase extends BackdropWebTestCase {

  /**
   * A user with permission to create and edit own page content.
   *
   * @var object
   */
  protected $web_user;

  /**
   * A user with permission to bypass node access and administer nodes.
   *
   * @var object
   */
  protected $admin_user;

  function setUp() {
    parent::setUp();

    $this->web_user = $this->backdropCreateUser(array('edit own page content', 'create page content'));
    $this->admin_user = $this->backdropCreateUser(array('bypass node access', 'administer nodes'));
  }

  /**
   * Checks node edit functionality.
   */
  function testPageEdit() {
    $this->backdropLogin($this->web_user);

    $langcode = LANGUAGE_NONE;
    $title_key = "title";
    $body_key = "body[$langcode][0][value]";
    // Create node to edit.
    $edit = array();
    $edit[$title_key] = $this->randomName(8);
    $edit[$body_key] = $this->randomName(16);
    $this->backdropPost('node/add/page', $edit, t('Save'));

    // Check that the node exists in the database.
    $node = $this->backdropGetNodeByTitle($edit[$title_key]);
    $this->assertTrue($node, 'Node found in database.');

    // Check that "edit" link points to correct page.
    $this->clickLink(t('Edit'));
    $edit_url = url("node/$node->nid/edit", array('absolute' => TRUE));
    $actual_url = $this->getURL();
    $this->assertEqual($edit_url, $actual_url, 'On edit page.');

    // Check that the title and body fields are displayed with the correct values.
    $active = '<span class="element-invisible">' . t('(active tab)') . '</span>';
    $link_text = t('!local-task-title!active', array('!local-task-title' => t('Edit'), '!active' => $active));
    $this->assertText(strip_tags($link_text), 0, 'Edit tab found and marked active.');
    $this->assertFieldByName($title_key, $edit[$title_key], 'Title field displayed.');
    $this->assertFieldByName($body_key, $edit[$body_key], 'Body field displayed.');

    // Edit the content of the node.
    $edit = array();
    $edit[$title_key] = $this->randomName(8);
    $edit[$body_key] = $this->randomName(16);
    // Stay on the current page, without reloading.
    $this->backdropPost(NULL, $edit, t('Save'));

    // Check that the title and body fields are displayed with the updated values.
    $this->assertText($edit[$title_key], 'Title displayed.');
    $this->assertText($edit[$body_key], 'Body displayed.');

    // Login as a second administrator user.
    $second_web_user = $this->backdropCreateUser(array('administer nodes', 'edit any page content'));
    $this->backdropLogin($second_web_user);
    // Edit the same node, creating a new revision.
    $this->backdropGet("node/$node->nid/edit");
    $edit = array();
    $edit['title'] = $this->randomName(8);
    $edit[$body_key] = $this->randomName(16);
    $edit['revision'] = TRUE;
    $this->backdropPost(NULL, $edit, t('Save'));

    // Ensure that the node revision has been created.
    $revised_node = $this->backdropGetNodeByTitle($edit['title']);
    $this->assertNotIdentical($node->vid, $revised_node->vid, 'A new revision has been created.');
    // Ensure that the node author is preserved when it was not changed in the
    // edit form.
    $this->assertIdentical($node->uid, $revised_node->uid, 'The node author has been preserved.');
    // Ensure that the revision authors are different since the revisions were
    // made by different users.
    $first_node_version = node_load($node->nid, $node->vid);
    $second_node_version = node_load($node->nid, $revised_node->vid);
    $this->assertNotIdentical($first_node_version->revision_uid, $second_node_version->revision_uid, 'Each revision has a distinct user.');
  }

  /**
   * Tests changing a node's "authored by" field.
   */
  function testPageAuthoredBy() {
    $this->backdropLogin($this->admin_user);

    // Create node to edit.
    $langcode = LANGUAGE_NONE;
    $body_key = "body[$langcode][0][value]";
    $edit = array();
    $edit['title'] = $this->randomName(8);
    $edit[$body_key] = $this->randomName(16);
    $this->backdropPost('node/add/page', $edit, t('Save'));

    // Check that the node was authored by the currently logged in user.
    $node = $this->backdropGetNodeByTitle($edit['title']);
    $this->assertIdentical($node->uid, $this->admin_user->uid, 'Node authored by admin user.');

    // Try to change the 'authored by' field to an invalid user name.
    $edit = array(
      'name' => 'invalid-name',
    );
    $this->backdropPost('node/' . $node->nid . '/edit', $edit, t('Save'));
    $this->assertText('The username invalid-name does not exist.');

    // Change the authored by field to an empty string, which should assign
    // authorship to the anonymous user (uid 0).
    $edit['name'] = '';
    $this->backdropPost('node/' . $node->nid . '/edit', $edit, t('Save'));
    $node = node_load($node->nid, NULL, TRUE);
    $this->assertIdentical($node->uid, '0', 'Node authored by anonymous user.');

    // Change the authored by field to another user's name (that is not
    // logged in).
    $edit['name'] = $this->web_user->name;
    $this->backdropPost('node/' . $node->nid . '/edit', $edit, t('Save'));
    $node = node_load($node->nid, NULL, TRUE);
    $this->assertIdentical($node->uid, $this->web_user->uid, 'Node authored by normal user.');

    // Check that normal users cannot change the authored by information.
    $this->backdropLogin($this->web_user);
    $this->backdropGet('node/' . $node->nid . '/edit');
    $this->assertNoFieldByName('name');
  }
}

/**
 * Tests creating and saving a node.
 */
class NodeCreationTestCase extends BackdropWebTestCase {
  function setUp() {
    // Enable dummy module that implements hook_node_insert for exceptions.
    parent::setUp('node_test_exception');

    $web_user = $this->backdropCreateUser(array('create page content', 'edit own page content'));
    $this->backdropLogin($web_user);
  }

  /**
   * Creates a "Page" node and verifies its consistency in the database.
   */
  function testNodeCreation() {
    // Create a node.
    $edit = array();
    $langcode = LANGUAGE_NONE;
    $edit["title"] = $this->randomName(8);
    $edit["body[$langcode][0][value]"] = $this->randomName(16);
    $this->backdropPost('node/add/page', $edit, t('Save'));

    // Check that the Page has been created.
    $this->assertRaw(t('!post %title has been created.', array('!post' => 'Page', '%title' => $edit["title"])), 'Page created.');

    // Check that the node exists in the database.
    $node = $this->backdropGetNodeByTitle($edit["title"]);
    $this->assertTrue($node, 'Node found in database.');
  }

  /**
   * Verifies that a transaction rolls back the failed creation.
   */
  function testFailedPageCreation() {
    // Create a node.
    $edit = array(
      'uid'      => $this->loggedInUser->uid,
      'name'     => $this->loggedInUser->name,
      'type'     => 'page',
      'langcode' => LANGUAGE_NONE,
      'title'    => 'testing_transaction_exception',
    );

    try {
      // An exception is generated by node_test_exception_node_insert() if the
      // title is 'testing_transaction_exception'.
      entity_create('node', $edit)->save();
      $this->fail(t('Expected exception has not been thrown.'));
    }
    catch (Exception $e) {
      $this->pass(t('Expected exception has been thrown.'));
    }

    if (Database::getConnection()->supportsTransactions()) {
      // Check that the node does not exist in the database.
      $node = $this->backdropGetNodeByTitle($edit['title']);
      $this->assertFalse($node, 'Transactions supported, and node not found in database.');
    }
    else {
      // Check that the node exists in the database.
      $node = $this->backdropGetNodeByTitle($edit['title']);
      $this->assertTrue($node, 'Transactions not supported, and node found in database.');

      // Check that the failed rollback was logged.
      $records = db_query("SELECT wid FROM {watchdog} WHERE message LIKE 'Explicit rollback failed%'")->fetchAll();
      $this->assertTrue(count($records) > 0, 'Transactions not supported, and rollback error logged to watchdog.');
    }

    // Check that the rollback error was logged.
    $records = db_query("SELECT wid FROM {watchdog} WHERE variables LIKE '%Test exception for rollback.%'")->fetchAll();
    $this->assertTrue(count($records) > 0, 'Rollback explanatory error logged to watchdog.');
  }

  /**
   * Create an unpublished node and confirm correct redirect behavior.
   */
  function testUnpublishedNodeCreation() {
    // Set "Page" content type to be unpublished by default.
    $node_type = node_type_get_type('page');
    $node_type->settings['status_default'] = 0;
    node_type_save($node_type);

    // Set the front page to the default "node" page.
    config_set('system.core', 'site_frontpage', 'node');

    // Create a node.
    $edit = array();
    $edit["title"] = $this->randomName(8);
    $edit["body[" . LANGUAGE_NONE . "][0][value]"] = $this->randomName(16);
    $this->backdropPost('node/add/page', $edit, t('Save'));

    // Check that the user was redirected to the home page.
    $this->assertText(t('This is your first post! You may edit or delete it.'), 'The user is redirected to the home page.');
  }
}

/**
 * Tests the functionality of node entity edit permissions.
 */
class PageViewTestCase extends BackdropWebTestCase {
  /**
   * Tests an anonymous and unpermissioned user attempting to edit the node.
   */
  function testPageView() {
    // Create a node to view.
    $node = $this->backdropCreateNode();
    $this->assertTrue(node_load($node->nid), 'Node created.');

    // Try to edit with anonymous user.
    $html = $this->backdropGet("node/$node->nid/edit");
    $this->assertResponse(403);

    // Create a user without permission to edit node.
    $web_user = $this->backdropCreateUser(array('access content'));
    $this->backdropLogin($web_user);

    // Attempt to access edit page.
    $this->backdropGet("node/$node->nid/edit");
    $this->assertResponse(403);

    // Create user with permission to edit node.
    $web_user = $this->backdropCreateUser(array('bypass node access'));
    $this->backdropLogin($web_user);

    // Attempt to access edit page.
    $this->backdropGet("node/$node->nid/edit");
    $this->assertResponse(200);
  }
}

/**
 * Tests the summary length functionality.
 */
class SummaryLengthTestCase extends BackdropWebTestCase {
  /**
   * Tests the node summary length functionality.
   */
  function testSummaryLength() {
    // Create a node to view.
    $settings = array(
      'body' => array(LANGUAGE_NONE => array(array('value' => 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam vitae arcu at leo cursus laoreet. Curabitur dui tortor, adipiscing malesuada tempor in, bibendum ac diam. Cras non tellus a libero pellentesque condimentum. What is a foobar? Suspendisse ac lacus libero. Ut non est vel nisl faucibus interdum nec sed leo. Pellentesque sem risus, vulputate eu semper eget, auctor in libero. Ut fermentum est vitae metus convallis scelerisque. Phasellus pellentesque rhoncus tellus, eu dignissim purus posuere id. Quisque eu fringilla ligula. Morbi ullamcorper, lorem et mattis egestas, tortor neque pretium velit, eget eleifend odio turpis eu purus. Donec vitae metus quis leo pretium tincidunt a pulvinar sem. Morbi adipiscing laoreet mauris vel placerat. Nullam elementum, nisl sit amet scelerisque malesuada, dolor nunc hendrerit quam, eu ultrices erat est in orci. Curabitur feugiat egestas nisl sed accumsan.'))),
      'promote' => 1,
    );
    $node = $this->backdropCreateNode($settings);
    $this->assertTrue(node_load($node->nid), t('Node created.'));

    // Create user with permission to view the node.
    $web_user = $this->backdropCreateUser(array('access content', 'administer content types'));
    $this->backdropLogin($web_user);

    // Attempt to access the front page.
    $this->backdropGet("node");
    // The node teaser when it has 600 characters in length
    $expected = 'What is a foobar?';
    $this->assertRaw($expected, 'Check that the summary is 600 characters in length', 'Node');

    // Change the teaser length for "Page" content type.
    $instance = field_info_instance('node', 'body', $node->type);
    $instance['display']['teaser']['settings']['trim_length'] = 200;
    field_update_instance($instance);

    // Attempt to access the front page again and check if the summary is now only 200 characters in length.
    $this->backdropGet("node");
    $this->assertNoRaw($expected, 'Check that the summary is not longer than 200 characters', 'Node');
  }
}

/**
 * Tests XSS functionality with a node entity.
 */
class NodeTitleXSSTestCase extends BackdropWebTestCase {
  /**
   * Tests XSS functionality with a node entity.
   */
  function testNodeTitleXSS() {
    // Prepare a user to do the stuff.
    $web_user = $this->backdropCreateUser(array('create page content', 'edit any page content'));
    $this->backdropLogin($web_user);

    $xss = '<script>alert("xss")</script>';
    $title = $xss . $this->randomName();
    $edit = array("title" => $title);

    $settings = array('title' => $title);
    $node = $this->backdropCreateNode($settings);

    $this->backdropGet('node/' . $node->nid);
    // assertTitle() decodes HTML-entities inside the <title> element.
    $this->assertTitle($edit["title"] . ' | Backdrop CMS', 'Title is displayed when viewing a node.');
    $this->assertNoRaw($xss, 'Harmful tags are escaped when viewing a node.');

    $this->backdropGet('node/' . $node->nid . '/edit');
    $this->assertNoRaw($xss, 'Harmful tags are escaped when editing a node.');
  }
}

/**
 * Tests the availability of the syndicate block.
 */
class NodeBlockTestCase extends BackdropWebTestCase {
  function setUp() {
    parent::setUp();

    // Create and login user
    $admin_user = $this->backdropCreateUser(array('administer blocks'));
    $this->backdropLogin($admin_user);
  }

  /**
   * Tests that the "Syndicate" block is shown when enabled.
   */
  function testSyndicateBlock() {
    $layout = layout_load('home');
    $layout->addBlock('node', 'syndicate', 'footer');
    $layout->save();

    $syndicate_selector = '//*[contains(@class,"block-node-syndicate")]//a[contains(@class,"feed-icon")]';

    $this->backdropGet('<front>');
    $elements = $this->xpath($syndicate_selector);
    $this->assertEqual(count($elements), 1, 'Syndicate block found on front page.');

    $this->backdropGet('user');
    $elements = $this->xpath($syndicate_selector);
    $this->assertEqual(count($elements), 0, 'Syndicate block not shown on /user.');
  }
}

/**
 * Checks that the post information displays when enabled for a content type.
 */
class NodePostSettingsTestCase extends BackdropWebTestCase {
  function setUp() {
    parent::setUp();

    // Use Stark for expected markup checking.
    theme_enable(array('stark'));
    config_set('system.core', 'theme_default', 'stark');

    $web_user = $this->backdropCreateUser(array('create page content', 'administer content types', 'access user profiles'));
    $this->backdropLogin($web_user);
  }

  /**
   * Confirms "Page" content type and post information is on a new node.
   */
  function testPagePostInfo() {

    // Set "Page" content type to display post information.
    $edit = array();
    $edit['node_submitted'] = TRUE;
    $this->backdropPost('admin/structure/types/manage/page', $edit, t('Save content type'));

    // Create a node.
    $edit = array();
    $langcode = LANGUAGE_NONE;
    $edit["title"] = $this->randomName(8);
    $edit["body[$langcode][0][value]"] = $this->randomName(16);
    $this->backdropPost('node/add/page', $edit, t('Save'));

    // Check that the post information is displayed.
    $elements = $this->xpath('//p[contains(@class, :class)]', array(':class' => 'submitted'));
    $this->assertEqual(count($elements), 1, 'Post information is displayed.');
  }

  /**
   * Confirms absence of post information on a new node.
   */
  function testPageNotPostInfo() {

    // Set "Page" content type to display post information.
    $edit = array();
    $edit['node_submitted'] = FALSE;
    $this->backdropPost('admin/structure/types/manage/page', $edit, t('Save content type'));

    // Create a node.
    $edit = array();
    $langcode = LANGUAGE_NONE;
    $edit["title"] = $this->randomName(8);
    $edit["body[$langcode][0][value]"] = $this->randomName(16);
    $this->backdropPost('node/add/page', $edit, t('Save'));

    // Check that the post information is displayed.
    $node = $this->backdropGetNodeByTitle($edit["title"]);
    $this->assertNoRaw('<span class="submitted">', 'Post information is not displayed.');
  }
}

/**
 * Ensures that data added to nodes by other modules appears in RSS feeds.
 *
 * Create a node, enable the node_test module to ensure that extra data is
 * added to the node->content array, then verify that the data appears on the
 * sitewide RSS feed at rss.xml.
 */
class NodeRSSContentTestCase extends BackdropWebTestCase {
  protected $profile = 'testing';

  function setUp() {
    // Enable dummy module that implements hook_node_view.
    parent::setUp('node_test');
    module_disable(array('views'));

    $this->backdropCreateContentType(array('type' => 'post', 'name' => 'Post'));
    // Use bypass node access permission here, because the test class uses
    // hook_grants_alter() to deny access to everyone on node_access
    // queries.
    $user = $this->backdropCreateUser(array('bypass node access', 'access content', 'create post content'));
    $this->backdropLogin($user);
  }

  /**
   * Ensures that a new node includes the custom data when added to an RSS feed.
   */
  function testNodeRSSContent() {
    // Create a node.
    $node = $this->backdropCreateNode(array('type' => 'post', 'promote' => 1));

    $this->backdropGet('rss.xml');

    // Check that content added in 'rss' view mode appear in RSS feed.
    $rss_only_content = t('Extra data that should appear only in the RSS feed for node !nid.', array('!nid' => $node->nid));
    $this->assertText($rss_only_content, 'Node content designated for RSS appear in RSS feed.');

    // Check that it renders just the xml of the feed not the html.
    $this->assertNoRaw('<!DOCTYPE html>', 'Node content in the feed is just XML not HTML.');

    // Check that content added in view modes other than 'rss' doesn't
    // appear in RSS feed.
    $non_rss_content = t('Extra data that should appear everywhere except the RSS feed for node !nid.', array('!nid' => $node->nid));
    $this->assertNoText($non_rss_content, "Node content not designed for RSS doesn't appear in RSS feed.");

    // Check that extra RSS elements and namespaces are added to RSS feed.
    $test_element = array(
      'key' => 'testElement',
      'value' => t('Value of testElement RSS element for node !nid.', array('!nid' => $node->nid)),
    );
    $test_ns = 'xmlns:backdroptest="http://example.com/test-namespace"';
    $this->assertRaw(format_xml_elements(array($test_element)), 'Extra RSS elements appear in RSS feed.');
    $this->assertRaw($test_ns, 'Extra namespaces appear in RSS feed.');

    // Check that content added in 'rss' view mode doesn't appear when
    // viewing node.
    $this->backdropGet("node/$node->nid");
    $this->assertNoText($rss_only_content, "Node content designed for RSS doesn't appear when viewing node.");

    // Check that the node feed page does not try to interpret additional path
    // components as arguments for node_feed() and returns default content.
    $this->backdropGet('rss.xml/' . $this->randomName() . '/' . $this->randomName());
    $this->assertText($rss_only_content, 'Ignore page arguments when delivering rss.xml.');
  }
}

/**
 * Tests basic node_access functionality.
 *
 * Note that hook_node_access_records() is covered in another test class.
 *
 * @todo Cover hook_node_access in a separate test class.
 */
class NodeAccessUnitTest extends BackdropWebTestCase {
  protected $profile = 'testing';

  /**
   * Asserts node_access() correctly grants or denies access.
   */
  function assertNodeAccess($ops, $node, $account) {
    foreach ($ops as $op => $result) {
      $msg = format_string("node_access returns @result with operation '@op'.", array('@result' => $result ? 'true' : 'false', '@op' => $op));
      $this->assertEqual($result, node_access($op, $node, $account), $msg);
    }
  }

  function setUp() {
    parent::setUp();

    // Create content types for testing.
    $this->backdropCreateContentType(array('type' => 'page', 'name' => 'Page'));
    $this->backdropCreateContentType(array('type' => 'post', 'name' => 'Post'));

    // Clear permissions for authenticated users.
    $role = user_role_load(BACKDROP_AUTHENTICATED_ROLE);
    $role->permissions = array();
    user_role_save($role);
  }

  /**
   * Runs basic tests for node_access function.
   */
  function testNodeAccess() {
    // Ensures user without 'access content' permission can do nothing.
    $web_user1 = $this->backdropCreateUser(array('create page content', 'edit any page content', 'delete any page content'));
    $node1 = $this->backdropCreateNode(array('type' => 'page'));
    $this->assertNodeAccess(array('create' => FALSE), 'page', $web_user1);
    $this->assertNodeAccess(array('view' => FALSE, 'update' => FALSE, 'delete' => FALSE), $node1, $web_user1);

    // Ensures user with 'bypass node access' permission can do everything.
    $web_user2 = $this->backdropCreateUser(array('bypass node access'));
    $node2 = $this->backdropCreateNode(array('type' => 'page'));
    $this->assertNodeAccess(array('create' => TRUE), 'page', $web_user2);
    $this->assertNodeAccess(array('view' => TRUE, 'update' => TRUE, 'delete' => TRUE), $node2, $web_user2);

    // User cannot 'view own unpublished content'.
    $web_user3 = $this->backdropCreateUser(array('access content'));
    $node3 = $this->backdropCreateNode(array('status' => 0, 'uid' => $web_user3->uid));
    $this->assertNodeAccess(array('view' => FALSE), $node3, $web_user3);

    // User cannot create content without permission.
    $this->assertNodeAccess(array('create' => FALSE), 'page', $web_user3);

    // User can 'view own unpublished content', but another user cannot.
    $web_user4 = $this->backdropCreateUser(array('access content', 'view own unpublished content'));
    $web_user5 = $this->backdropCreateUser(array('access content', 'view own unpublished content'));
    $node4 = $this->backdropCreateNode(array('status' => 0, 'uid' => $web_user4->uid));
    $this->assertNodeAccess(array('view' => TRUE, 'update' => FALSE), $node4, $web_user4);
    $this->assertNodeAccess(array('view' => FALSE), $node4, $web_user5);

    // User can 'view all unpublished content'.
    $web_user6 = $this->backdropCreateUser(array('access content', 'view any unpublished content'));
    $this->assertNodeAccess(array('view' => TRUE, 'update' => FALSE), $node4, $web_user6);
    $node5 = $this->backdropCreateNode(array('status' => 0, 'uid' => $web_user5->uid));
    $this->assertNodeAccess(array('view' => TRUE, 'update' => FALSE), $node5, $web_user6);

    // Tests the default access provided for a published node.
    $node5 = $this->backdropCreateNode();
    $this->assertNodeAccess(array('view' => TRUE, 'update' => FALSE, 'delete' => FALSE), $node5, $web_user3);
  }
}

/**
 * Tests hook_node_access_records() functionality.
 */
class NodeAccessRecordsUnitTest extends BackdropWebTestCase {
  protected $profile = 'testing';

  function setUp() {
    // Enable dummy module that implements hook_node_grants(),
    // hook_node_access_records(), hook_node_grants_alter() and
    // hook_node_access_records_alter().
    parent::setUp('node_test');

    // Create content types for testing.
    $this->backdropCreateContentType(array('type' => 'page', 'name' => 'Page'));
    $this->backdropCreateContentType(array('type' => 'post', 'name' => 'Post'));
  }

  /**
   * Creates a node and tests the creation of node access rules.
   */
  function testNodeAccessRecords() {
    // Create a post node.
    $node1 = $this->backdropCreateNode(array('type' => 'post'));
    $this->assertTrue(node_load($node1->nid), 'Post node created.');

    // Check to see if grants added by node_test_node_access_records made it in.
    $records = db_query('SELECT realm, gid FROM {node_access} WHERE nid = :nid', array(':nid' => $node1->nid))->fetchAll();
    $this->assertEqual(count($records), 1, 'Returned the correct number of rows.');
    $this->assertEqual($records[0]->realm, 'test_post_realm', 'Grant with post_realm acquired for node without alteration.');
    $this->assertEqual($records[0]->gid, 1, 'Grant with gid = 1 acquired for node without alteration.');

    // Create an unpromoted "Page" node.
    $node2 = $this->backdropCreateNode(array('type' => 'page', 'promote' => 0));
    $this->assertTrue(node_load($node2->nid), 'Unpromoted page node created.');

    // Check to see if grants added by node_test_node_access_records made it in.
    $records = db_query('SELECT realm, gid FROM {node_access} WHERE nid = :nid', array(':nid' => $node2->nid))->fetchAll();
    $this->assertEqual(count($records), 1, 'Returned the correct number of rows.');
    $this->assertEqual($records[0]->realm, 'test_page_realm', 'Grant with page_realm acquired for node without alteration.');
    $this->assertEqual($records[0]->gid, 1, 'Grant with gid = 1 acquired for node without alteration.');

    // Create an unpromoted, unpublished "Page" node.
    $node3 = $this->backdropCreateNode(array('type' => 'page', 'promote' => 0, 'status' => 0));
    $this->assertTrue(node_load($node3->nid), 'Unpromoted, unpublished page node created.');

    // Check to see if grants added by node_test_node_access_records made it in.
    $records = db_query('SELECT realm, gid FROM {node_access} WHERE nid = :nid', array(':nid' => $node3->nid))->fetchAll();
    $this->assertEqual(count($records), 1, 'Returned the correct number of rows.');
    $this->assertEqual($records[0]->realm, 'test_page_realm', 'Grant with page_realm acquired for node without alteration.');
    $this->assertEqual($records[0]->gid, 1, 'Grant with gid = 1 acquired for node without alteration.');

    // Create a promoted "Page" node.
    $node4 = $this->backdropCreateNode(array('type' => 'page', 'promote' => 1));
    $this->assertTrue(node_load($node4->nid), 'Promoted page node created.');

    // Check to see if grant added by node_test_node_access_records was altered
    // by node_test_node_access_records_alter.
    $records = db_query('SELECT realm, gid FROM {node_access} WHERE nid = :nid', array(':nid' => $node4->nid))->fetchAll();
    $this->assertEqual(count($records), 1, 'Returned the correct number of rows.');
    $this->assertEqual($records[0]->realm, 'test_alter_realm', 'Altered grant with alter_realm acquired for node.');
    $this->assertEqual($records[0]->gid, 2, 'Altered grant with gid = 2 acquired for node.');

    // Check to see if we can alter grants with hook_node_grants_alter().
    $operations = array('view', 'update', 'delete');
    // Create a user that is allowed to access content.
    $web_user = $this->backdropCreateUser(array('access content'));
    foreach ($operations as $op) {
      $grants = node_test_node_grants($op, $web_user);
      $altered_grants = $grants;
      backdrop_alter('node_grants', $altered_grants, $web_user, $op);
      $this->assertNotEqual($grants, $altered_grants, format_string('Altered the %op grant for a user.', array('%op' => $op)));
    }

    // Check that core does not grant access to an unpublished node when an
    // empty $grants array is returned.
    $node6 = $this->backdropCreateNode(array('status' => 0, 'disable_node_access' => TRUE));
    $records = db_query('SELECT realm, gid FROM {node_access} WHERE nid = :nid', array(':nid' => $node6->nid))->fetchAll();
    $this->assertEqual(count($records), 0, 'Returned no records for unpublished node.');
  }
}

/**
 * Tests for Node Access with a non-node base table.
 */
class NodeAccessBaseTableTestCase extends BackdropWebTestCase {
  public function setUp() {
    parent::setUp('node_access_test');
    node_access_rebuild();
    state_set('node_access_test_private', TRUE);

    // Disable default path patterns for nodes.
    config_set('path.settings', 'node_pattern', '');
    config_set('path.settings', 'node_post_pattern', '');
  }

  /**
   * Tests the "private" node access functionality.
   *
   * - Create 2 users with "access content" and "create post" permissions.
   * - Each user creates one private and one not private post.
   * - Test that each user can view the other user's non-private post.
   * - Test that each user cannot view the other user's private post.
   * - Test that each user finds only appropriate (non-private + own private)
   *   in taxonomy listing.
   * - Create another user with 'view any private content'.
   * - Test that user 4 can view all content created above.
   * - Test that user 4 can view all content on taxonomy listing.
   */
  function testNodeAccessBasic() {
    $num_simple_users = 2;
    $simple_users = array();

    // nodes keyed by uid and nid: $nodes[$uid][$nid] = $is_private;
    $this->nodesByUser = array();
    $titles = array(); // Titles keyed by nid
    $private_nodes = array(); // Array of nids marked private.
    for ($i = 0; $i < $num_simple_users; $i++) {
      $simple_users[$i] = $this->backdropCreateUser(array('access content', 'create post content'));
    }
    foreach ($simple_users as $this->webUser) {
      $this->backdropLogin($this->webUser);
      foreach (array(0 => 'Public', 1 => 'Private') as $is_private => $type) {
        $edit = array(
          'title' => t('@private_public Post created by @user', array('@private_public' => $type, '@user' => $this->webUser->name)),
        );
        if ($is_private) {
          $edit['private'] = TRUE;
          $edit['body[und][0][value]'] = 'private node';
          $edit['field_tags[und]'] = 'private';
        }
        else {
          $edit['body[und][0][value]'] = 'public node';
          $edit['field_tags[und]'] = 'public';
        }

        $this->backdropPost('node/add/post', $edit, t('Save'));
        $nid = db_query('SELECT nid FROM {node} WHERE title = :title', array(':title' => $edit['title']))->fetchField();
        $private_status = db_query('SELECT private FROM {node_access_test} where nid = :nid', array(':nid' => $nid))->fetchField();
        $this->assertTrue($is_private == $private_status, 'The private status of the node was properly set in the node_access_test table.');
        if ($is_private) {
          $private_nodes[] = $nid;
        }
        $titles[$nid] = $edit['title'];
        $this->nodesByUser[$this->webUser->uid][$nid] = $is_private;
      }
    }
    $this->publicTid = db_query('SELECT tid FROM {taxonomy_term_data} WHERE name = :name', array(':name' => 'public'))->fetchField();
    $this->privateTid = db_query('SELECT tid FROM {taxonomy_term_data} WHERE name = :name', array(':name' => 'private'))->fetchField();
    $this->assertTrue($this->publicTid, 'Public tid was found');
    $this->assertTrue($this->privateTid, 'Private tid was found');
    foreach ($simple_users as $this->webUser) {
      $this->backdropLogin($this->webUser);
      // Check own nodes to see that all are readable.
      foreach ($this->nodesByUser as $uid => $data) {
        foreach ($data as $nid => $is_private) {
          $this->backdropGet('node/' . $nid);
          if ($is_private) {
            $should_be_visible = $uid == $this->webUser->uid;
          }
          else {
            $should_be_visible = TRUE;
          }
          $this->assertResponse($should_be_visible ? 200 : 403, strtr('A %private node by user %uid is %visible for user %current_uid.', array(
            '%private' => $is_private ? 'private' : 'public',
            '%uid' => $uid,
            '%visible' => $should_be_visible ? 'visible' : 'not visible',
            '%current_uid' => $this->webUser->uid,
          )));
        }
      }

      // Check to see that the correct nodes are shown on taxonomy/private
      // and taxonomy/public.
      $this->assertTaxonomyPage(FALSE);
    }

    // Now test that a user with 'access any private content' can view content.
    $access_user = $this->backdropCreateUser(array('access content', 'create post content', 'node test view', 'search content'));
    $this->backdropLogin($access_user);

    foreach ($this->nodesByUser as $uid => $private_status) {
      foreach ($private_status as $nid => $is_private) {
        $this->backdropGet('node/' . $nid);
        $this->assertResponse(200);
      }
    }

    // This user should be able to see all of the nodes on the relevant
    // taxonomy pages.
    $this->assertTaxonomyPage(TRUE);
  }

  /**
   * Checks taxonomy/term listings to ensure only accessible nodes are listed.
   *
   * @param $is_admin
   *   A boolean indicating whether the current user is an administrator. If
   *   TRUE, all nodes should be listed. If FALSE, only public nodes and the
   *   user's own private nodes should be listed.
   */
  protected function assertTaxonomyPage($is_admin) {
    foreach (array($this->publicTid, $this->privateTid) as $tid_is_private => $tid) {
      $this->backdropGet("taxonomy/term/$tid");
      $this->nids_visible = array();
      foreach ($this->xpath("//a[text()='Read more']") as $link) {
        $this->assertTrue(preg_match('|node/(\d+)$|', (string) $link['href'], $matches), 'Read more points to a node');
        $this->nids_visible[$matches[1]] = TRUE;
      }
      foreach ($this->nodesByUser as $uid => $data) {
        foreach ($data as $nid => $is_private) {
          // Private nodes should be visible on the private term page,
          // public nodes should be visible on the public term page.
          $should_be_visible = $tid_is_private == $is_private;
          // Non-administrators can only see their own nodes on the private
          // term page.
          if (!$is_admin && $tid_is_private) {
            $should_be_visible = $should_be_visible && $uid == $this->webUser->uid;
          }
          $this->assertIdentical(isset($this->nids_visible[$nid]), $should_be_visible, strtr('A %private node by user %uid is %visible for user %current_uid on the %tid_is_private page.', array(
            '%private' => $is_private ? 'private' : 'public',
            '%uid' => $uid,
            '%visible' => isset($this->nids_visible[$nid]) ? 'visible' : 'not visible',
            '%current_uid' => $this->webUser->uid,
            '%tid_is_private' => $tid_is_private ? 'private' : 'public',
          )));
        }
      }
    }
  }
}

/**
 * Tests node save related functionality, including import-save.
 */
class NodeSaveTestCase extends BackdropWebTestCase {
  protected $profile = 'testing';

  function setUp() {
    parent::setUp('node_test');
    $this->backdropCreateContentType(array('type' => 'post', 'name' => 'Post'));
    // Create a user that is allowed to post; we'll use this to test the submission.
    $web_user = $this->backdropCreateUser(array('create post content'));
    $this->backdropLogin($web_user);
    $this->web_user = $web_user;
  }

  /**
   * Checks whether custom node IDs are saved properly during an import operation.
   *
   * Workflow:
   *  - first create a piece of content
   *  - save the content
   *  - check if node exists
   */
  function testImport() {
    // Node ID must be a number that is not in the database.
    $max_nid = db_query('SELECT MAX(nid) FROM {node}')->fetchField();
    $test_nid = $max_nid + mt_rand(1000, 1000000);
    $title = $this->randomName(8);
    $node = array(
      'title' => $title,
      'body' => array(LANGUAGE_NONE => array(array('value' => $this->randomName(32)))),
      'uid' => $this->web_user->uid,
      'type' => 'post',
      'nid' => $test_nid,
      'is_new' => TRUE,
    );
    $node = node_submit(entity_create('node', $node));

    // Verify that node_submit did not overwrite the user ID.
    $this->assertEqual($node->uid, $this->web_user->uid, 'Function node_submit() preserves user ID');

    $node->save();
    // Test the import.
    $node_by_nid = node_load($test_nid);
    $this->assertTrue($node_by_nid, 'Node load by node ID.');

    $node_by_title = $this->backdropGetNodeByTitle($title);
    $this->assertTrue($node_by_title, 'Node load by node title.');
  }

  /**
   * Verifies accuracy of the "created" and "changed" timestamp functionality.
   */
  function testTimestamps() {
    // Use the default timestamps.
    $edit = array(
      'uid' => $this->web_user->uid,
      'type' => 'post',
      'title' => $this->randomName(8),
    );

    entity_create('node', $edit)->save();
    $node = $this->backdropGetNodeByTitle($edit['title']);
    $this->assertEqual($node->created, REQUEST_TIME, 'Creating a node sets default "created" timestamp.');
    $this->assertEqual($node->changed, REQUEST_TIME, 'Creating a node sets default "changed" timestamp.');

    // Store the timestamps.
    $created = $node->created;
    $changed = $node->changed;

    $node->save();
    $node = $this->backdropGetNodeByTitle($edit['title'], TRUE);
    $this->assertEqual($node->created, $created, 'Updating a node preserves "created" timestamp.');

    // Programmatically set the timestamps using hook_node_presave.
    $node->title = 'testing_node_presave';

    $node->save();
    $node = $this->backdropGetNodeByTitle('testing_node_presave', TRUE);
    $this->assertEqual($node->created, 280299600, 'Saving a node uses "created" timestamp set in presave hook.');
    $this->assertEqual($node->changed, 979534800, 'Saving a node uses "changed" timestamp set in presave hook.');

    // Programmatically set the timestamps on the node.
    $edit = array(
      'uid' => $this->web_user->uid,
      'type' => 'post',
      'title' => $this->randomName(8),
      'created' => 280299600, // Sun, 19 Nov 1978 05:00:00 GMT
      'changed' => 979534800, // Drupal 1.0 release.
    );

    entity_create('node', $edit)->save();
    $node = $this->backdropGetNodeByTitle($edit['title']);
    $this->assertEqual($node->created, 280299600, 'Creating a node uses user-set "created" timestamp.');
    $this->assertNotEqual($node->changed, 979534800, 'Creating a node doesn\'t use user-set "changed" timestamp.');

    // Update the timestamps.
    $node->created = 979534800;
    $node->changed = 280299600;

    $node->save();
    $node = $this->backdropGetNodeByTitle($edit['title'], TRUE);
    $this->assertEqual($node->created, 979534800, 'Updating a node uses user-set "created" timestamp.');
    $this->assertNotEqual($node->changed, 280299600, 'Updating a node doesn\'t use user-set "changed" timestamp.');
  }

  /**
   * Tests determing changes in hook_node_presave() and verifies the static node
   * load cache is cleared upon save.
   */
  function testDeterminingChanges() {
    // Initial creation.
    $node = entity_create('node', array(
      'uid' => $this->web_user->uid,
      'type' => 'post',
      'title' => 'test_changes',
    ));
    $node->save();

    // Update the node without applying changes.
    $node->save();
    $this->assertEqual($node->title, 'test_changes', 'No changes have been determined.');

    // Apply changes.
    $node->title = 'updated';
    $node->save();

    // The hook implementations node_test_node_presave() and
    // node_test_node_update() determine changes and change the title.
    $this->assertEqual($node->title, 'updated_presave_update', 'Changes have been determined.');

    // Test the static node load cache to be cleared.
    $node = node_load($node->nid);
    $this->assertEqual($node->title, 'updated_presave', 'Static cache has been cleared.');
  }

  /**
   * Tests saving a node on node insert.
   *
   * This test ensures that a node has been fully saved when hook_node_insert()
   * is invoked, so that the node can be saved again in a hook implementation
   * without errors.
   *
   * @see node_test_node_insert()
   */
  function testNodeSaveOnInsert() {
    // node_test_node_insert() tiggers a save on insert if the title equals
    // 'new'.
    $node = $this->backdropCreateNode(array('title' => 'new'));
    $this->assertEqual($node->title, 'Node ' . $node->nid, 'Node saved on node insert.');
  }
}

/**
 * Tests related to node types.
 */
class NodeTypeTestCase extends BackdropWebTestCase {
  /**
   * Ensures that node type functions (node_type_get_*) work correctly.
   *
   * Load available node types and validate the returned data.
   */
  function testNodeTypeGetFunctions() {
    $node_types = node_type_get_types();
    $node_names = node_type_get_names();

    $this->assertTrue(isset($node_types['post']), 'Node type post is available.');
    $this->assertTrue(isset($node_types['page']), 'Node type page is available.');

    $this->assertEqual($node_types['post']->name, $node_names['post'], 'Correct node type base has been returned.');

    $this->assertEqual($node_types['post'], node_type_get_type('post'), 'Correct node type has been returned.');
    $this->assertEqual($node_types['post']->name, node_type_get_name('post'), 'Correct node type name has been returned.');
    $this->assertEqual($node_types['page']->base, node_type_get_base('page'), 'Correct node type base has been returned.');
  }

  /**
   * Tests creating a content type programmatically and via a form.
   */
  function testNodeTypeCreation() {
    // Create a content type programmaticaly.
    $type = $this->backdropCreateContentType();

    $config = config('node.type.' . $type->type);
    $this->assertFalse($config->isNew(), 'The new content type has been created in config.');

    // Login a test user.
    $web_user = $this->backdropCreateUser(array('create ' . $type->name . ' content'));
    $this->backdropLogin($web_user);

    $this->backdropGet('node/add/' . str_replace('_', '-', $type->name));
    $this->assertResponse(200, 'The new content type can be accessed at node/add.');

    // Create a content type via the user interface.
    $web_user = $this->backdropCreateUser(array('bypass node access', 'administer content types', 'administer fields'));
    $this->backdropLogin($web_user);
    $edit = array(
      'name' => 'foo',
      'title_label' => 'title for foo',
      'type' => 'foo',
    );
    $this->backdropPost('admin/structure/types/add', $edit, t('Save content type'));
    $config = config('node.type.foo');
    $this->assertFalse($config->isNew(), 'The new content type has been created in config.');
  }

  /**
   * Tests editing a node type using the UI.
   */
  function testNodeTypeEditing() {
    $web_user = $this->backdropCreateUser(array('bypass node access', 'administer content types', 'administer fields'));
    $this->backdropLogin($web_user);

    $instance = field_info_instance('node', 'body', 'page');
    $this->assertEqual($instance['label'], 'Body', 'Body field was found.');

    // Verify that title and body fields are displayed.
    $this->backdropGet('node/add/page');
    $this->assertRaw('Title', 'Title field was found.');
    $this->assertRaw('Body', 'Body field was found.');

    // Rename the title field.
    $edit = array(
      'title_label' => 'Foo',
    );
    $this->backdropPost('admin/structure/types/manage/page', $edit, t('Save content type'));
    // Refresh the field information for the rest of the test.
    field_info_cache_clear();

    $this->backdropGet('node/add/page');
    $this->assertRaw('Foo', 'New title label was displayed.');
    $this->assertNoRaw('Title', 'Old title label was not displayed.');

    // Change the name, machine name and description.
    $edit = array(
      'name' => 'Bar',
      'type' => 'bar',
      'description' => 'Lorem ipsum.',
    );
    $this->backdropPost('admin/structure/types/manage/page', $edit, t('Save content type'));
    field_info_cache_clear();

    $this->backdropGet('node/add');
    $this->assertRaw('Bar', 'New name was displayed.');
    $this->assertRaw('Lorem ipsum', 'New description was displayed.');
    $this->clickLink('Bar');
    $this->assertEqual(url('node/add/bar', array('absolute' => TRUE)), $this->getUrl(), 'New machine name was used in URL.');
    $this->assertRaw('Foo', 'Title field was found.');
    $this->assertRaw('Body', 'Body field was found.');

    // Remove the body field.
    $this->backdropPost('admin/structure/types/manage/bar/fields/body/delete', NULL, t('Delete'));
    // Resave the settings for this type.
    $this->backdropPost('admin/structure/types/manage/bar', array(), t('Save content type'));
    // Check that the body field doesn't exist.
    $this->backdropGet('node/add/bar');
    $this->assertNoRaw('Body', 'Body field was not found.');
  }

  /**
   * Tests that node types permissions are correctly set from the Node Type UI.
   */
  function testNodeTypePermissions() {
    // Create admin user.
    $admin_user = $this->backdropCreateUser(array(
      'bypass node access',
      'administer content types',
      'administer permissions',
      'administer users',
      'assign roles',
      'access user profiles',
    ));
    $this->backdropLogin($admin_user);

    // Create new role
    $role_name = $this->backdropCreateRole(array('access content'));
    $web_user = $this->backdropCreateUser();

    // Assign the role to a user.
    $this->backdropPost('user/' . $web_user->uid . '/edit', array("roles[$role_name]" => $role_name), t('Save'));

    // Check that the new role appears on the Node Type edit page.
    $this->backdropGet('admin/structure/types/manage/page');
    $this->assertText($role_name, "$role_name is found on node type form.");

    // Check that the new role does not have a permission which wasn't granted.
    $this->assertFieldByName($role_name . '[edit any page content]', 'edit any page content', "Role $role_name does not have edit any page content permission.");

    // On the Node Type page: change permissions for the "page" node type.
    $edit = array(
      $role_name . '[edit own page content]' => TRUE,
    );
    $this->backdropPost('admin/structure/types/manage/page', $edit, t('Save content type'));

    // Check that the permission changes are saved on the permissions page.
    $this->backdropGet('admin/config/people/permissions');
    $this->assertFieldByName($role_name . '[edit own page content]', 'edit own page content', "Role $role_name has edit own page content permission.");

    // Check that the new role does not have a permission which wasn't granted.
    $this->assertFieldByName($role_name . '[edit any page content]', 'edit any page content', "Role $role_name does not have edit any page content permission.");

    // On the Permissions page: change permissions for the "page" node type.
    $edit = array(
      $role_name . '[edit any page content]' => TRUE,
    );
    $this->backdropPost('admin/config/people/permissions', $edit, t('Save permissions'));

    // Check that this permission is now selected on the Node Type page.
    $this->backdropGet('admin/structure/types/manage/page');
    $this->assertFieldByName($role_name . '[edit any page content]', 'edit any page content', "Role $role_name has edit any page content permission.");

    // Test that the permissions actually exist
    $this->backdropLogin($web_user);
    backdrop_static_reset('user_roles');
    backdrop_static_reset('user_access');

    $account = user_load($web_user->uid, TRUE);
    $this->assertTrue(user_access('edit own page content', $account), "Web user has edit own page content permission.");
    $this->assertTrue(user_access('edit any page content', $account), "Web user has edit any page content permission.");
  }

  /**
   * Tests that node types correctly handle the 'disabled' flag.
   */
  function testNodeTypeStatus() {
    // Enable all core node modules, and all types should be active.
    module_enable(array('book'), FALSE);
    $types = node_type_get_types();
    foreach (array('book', 'post', 'page') as $type) {
      $this->assertTrue(isset($types[$type]), format_string('%type is found in node types.', array('%type' => $type)));
      $this->assertTrue(isset($types[$type]->disabled) && empty($types[$type]->disabled), format_string('%type type is enabled.', array('%type' => $type)));
    }

    // Disable book module and the respective type should still be active, since
    // it is not disabled in book_disable().
    module_disable(array('book'), FALSE);
    $types = node_type_get_types();
    $this->assertTrue(isset($types['book']) && empty($types['book']->disabled), "Book module's node type still active.");
    $this->assertTrue(isset($types['post']) && empty($types['post']->disabled), "Post node type still active.");
    $this->assertTrue(isset($types['page']) && empty($types['page']->disabled), "Page node type still active.");

    // Re-enable the modules and verify that the types are active again.
    module_enable(array('book'), FALSE);
    $types = node_type_get_types();
    foreach (array('book', 'post', 'page') as $type) {
      $this->assertTrue(isset($types[$type]), format_string('%type is found in node types.', array('%type' => $type)));
      $this->assertTrue(isset($types[$type]->disabled) && empty($types[$type]->disabled), format_string('%type type is enabled.', array('%type' => $type)));
    }
  }

  /**
   * Ensures that node_type_has_content function works correctly.
   *
   * Add new node type and test function returns correct result with and
   * without content present.
   */
  function testNodeTypeHasContent() {
    // Delete the two default nodes.
    node_delete_multiple(array(1, 2));

    // Test node type to assert no content has been created.
    $this->assertFalse(node_type_has_content('post'), 'The post node type has no content associated with it.');

    // Create a post.
    $node = new Node();
    $node->type = 'post';
    node_object_prepare($node);
    $node->title = 'A new post';
    node_save($node);

    // Test node type to assert content has been created.
    $this->assertTrue(node_type_has_content('post'), 'The post node type has content associated with it.');
  }
}

/**
 * Test node type customizations persistence.
 */
class NodeTypePersistenceTestCase extends BackdropWebTestCase {
  /**
   * Tests that node type customizations persist through disable and uninstall.
   */
  function testNodeTypeCustomizationPersistence() {
    $web_user = $this->backdropCreateUser(array('bypass node access', 'administer content types', 'administer modules'));
    $this->backdropLogin($web_user);

    // Enable the test module and verify that the test node type is in the DB
    // and is not disabled.
    module_enable(array('node_test'), FALSE);
    $config = config('node.type.test');
    $this->assertFalse($config->isNew(), 'Test node type found in config.');
    $this->assertEqual($config->get('disabled'), 0, 'Test node type is not disabled');

    // Check that test node type (uncustomized) shows up.
    $this->backdropGet('node/add');
    $this->assertText('test', 'Test type is found on node/add');

    // Customize book description.
    $description = $this->randomName();
    $edit = array('description' => $description);
    $this->backdropPost('admin/structure/types/manage/test', $edit, t('Save content type'));

    // Check that Test node type customization shows up.
    $this->backdropGet('node/add');
    $this->assertText($description, 'Customized description found');

    // Disable test node module and check that the node type gets disabled.
    module_disable(array('node_test'), FALSE);
    $node_type = node_type_get_type('test');
    $this->assertEqual($node_type->disabled, 1, 'Test node type is disabled');
    $this->backdropGet('node/add');
    $this->assertNoText('book', 'Test node type is not found on node/add');

    // Reenable the test node module and check that the customization survived
    // the module disable.
    module_enable(array('node_test'), FALSE);
    $node_type = node_type_get_type('test');
    $this->assertEqual($node_type->disabled, 0, 'Test node type is not disabled');
    $this->backdropGet('node/add');
    $this->assertText($description, 'Customized description found');

    // Disable and uninstall book.
    module_disable(array('node_test'), FALSE);
    backdrop_uninstall_modules(array('node_test'));
    $node_type = node_type_get_type('test');
    $this->assertTrue($node_type->disabled, 'Test node type still exists after uninstalling, but is disabled');
    $this->backdropGet('node/add');
    $this->assertNoText('test', 'Test type is no longer found on node/add');

    // Reenable the test node module and check that the customization survived
    // the module uninstall.
    module_enable(array('node_test'), FALSE);
    $this->backdropGet('node/add');
    $this->assertText($description, 'Customized description is found even after uninstall and reenable.');
  }
}

/**
 * Verifies the rebuild functionality for the node_access table.
 */
class NodeAccessRebuildTestCase extends BackdropWebTestCase {
  function setUp() {
    parent::setUp();

    $web_user = $this->backdropCreateUser(array('administer site configuration', 'access administration pages', 'access site reports'));
    $this->backdropLogin($web_user);
    $this->web_user = $web_user;
  }

  /**
   * Tests rebuilding the node access permissions table.
   */
  function testNodeAccessRebuild() {
    $this->backdropGet('admin/reports/status');
    $this->clickLink(t('Rebuild permissions'));
    $this->backdropPost(NULL, array(), t('Rebuild permissions'));
    $this->assertText(t('Content permissions have been rebuilt.'));
  }
}

/**
 * Tests node administration page functionality.
 */
class NodeAdminTestCase extends BackdropWebTestCase {
  protected $profile = 'testing';

  function setUp() {
    parent::setUp();

    // Create content types for testing.
    $this->backdropCreateContentType(array('type' => 'page', 'name' => 'Page'));
    $this->backdropCreateContentType(array('type' => 'post', 'name' => 'Post'));

    // Remove the "view own unpublished content" permission which is set
    // by default for authenticated users so we can test this permission
    // correctly.
    user_role_revoke_permissions(BACKDROP_AUTHENTICATED_ROLE, array('view own unpublished content'));

    $this->admin_user = $this->backdropCreateUser(array(
      'access administration pages',
      'access content overview',
      'administer nodes',
      'bypass node access',
    ));
    $this->base_user_1 = $this->backdropCreateUser(array('access content overview'));
    $this->base_user_2 = $this->backdropCreateUser(array('access content overview', 'view own unpublished content'));
    $this->base_user_3 = $this->backdropCreateUser(array('access content overview', 'bypass node access'));
    $this->base_user_4 = $this->backdropCreateUser(array('access content overview', 'view any unpublished content'));
  }

  /**
   * Tests that the table sorting works on the content admin pages.
   */
  function testContentAdminSort() {
    $this->backdropLogin($this->admin_user);
    foreach (array('dd', 'aa', 'DD', 'bb', 'cc', 'CC', 'AA', 'BB') as $index => $prefix) {
      $node = $this->backdropCreateNode(array('title' => $prefix . $this->randomName(6)));
      db_update('node')
        ->fields(array(
          'changed' => REQUEST_TIME + $index
        ))
        ->condition('nid', $node->nid)
        ->execute();
    }

    // Test that the default sort by node.changed DESC actually fires properly.
    $nodes_query = db_select('node', 'n')
      ->fields('n', array('nid'))
      ->orderBy('changed', 'DESC')
      ->execute()
      ->fetchCol();

    $nodes_form = array();
    $this->backdropGet('admin/content');
    foreach ($this->xpath('//table/tbody/tr/td/div/input/@value') as $input) {
      $nodes_form[] = (string) $input;
    }
    $this->assertEqual($nodes_query, $nodes_form, 'Nodes are sorted in the form according to the default query.');

    // Compare the rendered HTML node list to a query for the nodes ordered by
    // title to account for possible database-dependent sort order.
    $nodes_query = db_select('node', 'n')
      ->fields('n', array('nid'))
      ->orderBy('title')
      ->execute()
      ->fetchCol();

    $nodes_form = array();
    $this->backdropGet('admin/content', array('query' => array('sort' => 'asc', 'order' => 'title')));
    foreach ($this->xpath('//table/tbody/tr/td/div/input/@value') as $input) {
      $nodes_form[] = $input;
    }
    $this->assertEqual($nodes_query, $nodes_form, 'Nodes are sorted in the form the same as they are in the query.');
  }

  /**
   * Tests content overview with different user permissions.
   *
   * Taxonomy filters are tested separately.
   *
   * @see TaxonomyNodeFilterTestCase
   */
  function testContentAdminPages() {
    // Do not use any patterns for nodes in this test.
    config_set('path.settings', 'node_pattern', '');
    config_set('path.settings', 'node_page_pattern', '');

    $this->backdropLogin($this->admin_user);

    $nodes['published_page'] = $this->backdropCreateNode(array('type' => 'page'));
    $nodes['published_post'] = $this->backdropCreateNode(array('type' => 'post'));
    $nodes['unpublished_page_1'] = $this->backdropCreateNode(array('type' => 'page', 'uid' => $this->base_user_1->uid, 'status' => 0));
    $nodes['unpublished_page_2'] = $this->backdropCreateNode(array('type' => 'page', 'uid' => $this->base_user_2->uid, 'status' => 0));

    // Verify view, edit, and delete links for any content.
    $this->backdropGet('admin/content');
    $this->assertResponse(200);
    $index = 0;
    foreach ($nodes as $node) {
      $this->assertLinkByHref('node/' . $node->nid);
      $this->assertLinkByHref('node/' . $node->nid . '/edit');
      $this->assertLinkByHref('node/' . $node->nid . '/delete');
      // Verify tableselect.
      $this->assertFieldByName('bulk_form[' . $index . ']', '', 'Tableselect found.');
      $index++;
    }

    // Verify filtering by publishing status.
    $this->backdropGet('admin/content/node', array('query' => array('status' => '1')));

    $this->assertFieldByXPath('//select[@name="status"]', '1', 'Content list is filtered by status.');

    $this->assertLinkByHref('node/' . $nodes['published_page']->nid . '/edit');
    $this->assertLinkByHref('node/' . $nodes['published_post']->nid . '/edit');
    $this->assertNoLinkByHref('node/' . $nodes['unpublished_page_1']->nid . '/edit');

    // Verify filtering by status and content type.
    $this->backdropGet('admin/content/node', array('query' => array('status' => '1', 'type' => 'page')));

    $this->assertFieldByXPath('//select[@name="status"]', '1', 'Content list is filtered by status.');
    $this->assertFieldByXPath('//select[@name="type"]', 'page', 'Content list is filtered by content type.');

    $this->assertLinkByHref('node/' . $nodes['published_page']->nid . '/edit');
    $this->assertNoLinkByHref('node/' . $nodes['published_post']->nid . '/edit');

    // Verify no operation links are displayed for regular users.
    $this->backdropLogout();
    $this->backdropLogin($this->base_user_1);
    $this->backdropGet('admin/content');
    $this->assertResponse(200);
    $this->assertLinkByHref('node/' . $nodes['published_page']->nid);
    $this->assertLinkByHref('node/' . $nodes['published_post']->nid);
    $this->assertNoLinkByHref('node/' . $nodes['published_page']->nid . '/edit');
    $this->assertNoLinkByHref('node/' . $nodes['published_page']->nid . '/delete');
    $this->assertNoLinkByHref('node/' . $nodes['published_post']->nid . '/edit');
    $this->assertNoLinkByHref('node/' . $nodes['published_post']->nid . '/delete');

    // Verify no unpublished content is displayed without permission.
    $this->assertNoLinkByHref('node/' . $nodes['unpublished_page_1']->nid);
    $this->assertNoLinkByHref('node/' . $nodes['unpublished_page_1']->nid . '/edit');
    $this->assertNoLinkByHref('node/' . $nodes['unpublished_page_1']->nid . '/delete');

    // Verify no tableselect.
    $this->assertNoFieldByName('nodes[' . $nodes['published_page']->nid . ']', '', 'No tableselect found.');

    // Verify unpublished content is displayed with permission.
    $this->backdropLogout();
    $this->backdropLogin($this->base_user_2);
    $this->backdropGet('admin/content');
    $this->assertResponse(200);
    $this->assertLinkByHref('node/' . $nodes['unpublished_page_2']->nid);
    // Verify no operation links are displayed.
    $this->assertNoLinkByHref('node/' . $nodes['unpublished_page_2']->nid . '/edit');
    $this->assertNoLinkByHref('node/' . $nodes['unpublished_page_2']->nid . '/delete');

    // Verify user cannot see unpublished content of other users.
    $this->assertNoLinkByHref('node/' . $nodes['unpublished_page_1']->nid);
    $this->assertNoLinkByHref('node/' . $nodes['unpublished_page_1']->nid . '/edit');
    $this->assertNoLinkByHref('node/' . $nodes['unpublished_page_1']->nid . '/delete');

    // Verify no tableselect.
    $this->assertNoFieldByName('nodes[' . $nodes['unpublished_page_2']->nid . ']', '', 'No tableselect found.');

    // Verify node access can be bypassed.
    $this->backdropLogout();
    $this->backdropLogin($this->base_user_3);
    $this->backdropGet('admin/content');
    $this->assertResponse(200);
    foreach ($nodes as $node) {
      $this->assertLinkByHref('node/' . $node->nid);
      $this->assertLinkByHref('node/' . $node->nid . '/edit');
      $this->assertLinkByHref('node/' . $node->nid . '/delete');
    }

    // Verify 'view any unpubished content' allows view but not edit or delete.
    $this->backdropLogout();
    $this->backdropLogin($this->base_user_4);
    $this->backdropGet('admin/content');
    $this->assertResponse(200);
    foreach ($nodes as $node) {
      $this->assertLinkByHref('node/' . $node->nid);
      $this->assertNoLinkByHref('node/' . $node->nid . '/edit');
      $this->assertNoLinkByHref('node/' . $node->nid . '/delete');
    }
  }
}

/**
 * Tests node title functionality.
 */
class NodeTitleTestCase extends BackdropWebTestCase {

  /**
   * A user with permission to create and edit content and to administer nodes.
   *
   * @var object
   */
  protected $admin_user;

  function setUp() {
    parent::setUp();

    // Use Stark for expected markup checking.
    theme_enable(array('stark'));
    config_set('system.core', 'theme_default', 'stark');

    $this->admin_user = $this->backdropCreateUser(array('administer nodes', 'create post content', 'create page content'));
    $this->backdropLogin($this->admin_user);
  }

  /**
   *  Creates one node and tests if the node title has the correct value.
   */
  function testNodeTitle() {
    // Create "Page" content with title.
    // Add the node to the frontpage so we can test if teaser links are clickable.
    $settings = array(
      'title' => $this->randomName(8),
      'promote' => 1,
    );
    $node = $this->backdropCreateNode($settings);

    // Test <title> tag.
    $this->backdropGet("node/$node->nid");
    $xpath = '//title';
    $this->assertEqual(current($this->xpath($xpath)), $node->title .' | Backdrop CMS', 'Page title is equal to node title.', 'Node');

    // Test breadcrumb in comment preview.
    $this->backdropGet("comment/reply/$node->nid");
    $xpath = '//nav[@class="breadcrumb"]/ol/li[last()]/a';
    $this->assertEqual(current($this->xpath($xpath)), $node->title, 'Node breadcrumb is equal to node title.', 'Node');

    // Test node title in comment preview.
    $this->assertEqual(current($this->xpath('//article[@id=:id]//h2/a', array(':id' => 'node-' . $node->nid))), $node->title, 'Node preview title is equal to node title.', 'Node');

    // Test node title is clickable on teaser list (/node).
    $this->backdropGet('node');
    $this->clickLink($node->title);
  }
}

/**
 * Test the node_feed() functionality.
 */
class NodeFeedTestCase extends BackdropWebTestCase {
  /**
   * Ensures that node_feed() accepts and prints extra channel elements.
   */
  function testNodeFeedExtraChannelElements() {
    ob_start();
    node_feed(array(), array('copyright' => 'Copyright Backdrop CMS.'));
    $output = ob_get_clean();

    $this->assertTrue(strpos($output, '<copyright>Copyright Backdrop CMS.</copyright>') !== FALSE);
  }
}

/**
 * Test toggle between custom front page callback and default /node callback.
 */
class NodeFrontPageCallback extends BackdropWebTestCase {
  function setUp() {
    parent::setUp('node', 'system');

    $this->admin_user = $this->backdropCreateUser(
      array(
        'administer site configuration',
        'administer nodes',
        'create post content',
        'create page content'
      )
    );
    $this->backdropLogin($this->admin_user);
  }

  function testCustomFrontPage() {
    $settings = array(
      'title' => $this->randomName(8),
      'promote' => 0,
    );
    // Set a custom front page.
    $node = $this->backdropCreateNode($settings);
    $edit['site_frontpage'] = 'node/' . $node->nid;
    $this->backdropPost('admin/config/system/site-information', $edit, t('Save configuration'));
    $this->backdropGet('<front>');
    $this->assertNoText(t('No content has been promoted yet.'), 'Confirmed /home is not the frontpage.');
    $this->assertText($node->title);

    // Set back to default front page.
    $edit['site_frontpage'] = 'home';
    $this->backdropPost('admin/config/system/site-information', $edit, t('Save configuration'));
    $this->backdropGet('<front>');
    $this->assertText(t('This is your first post! You may edit or delete it.'), "Default /home front page restored.");
  }
}

/**
 * Functional tests for the node module blocks.
 */
class NodeBlockFunctionalTest extends BackdropWebTestCase {

  function setUp() {
    parent::setUp('node', 'block');

    // Create users and test node.
    $this->admin_user = $this->backdropCreateUser(array(
      'administer content types',
      'administer nodes',
      'administer blocks',
      'administer layouts',
    ));
    $this->web_user = $this->backdropCreateUser(array('access content', 'create post content'));

    // Delete the two default nodes.
    node_delete_multiple(array(1, 2));
  }

  /**
   * Tests the recent comments block.
   */
  function testRecentNodeBlock() {
    $this->backdropLogin($this->admin_user);

    // Disallow anonymous users to view content.
    user_role_change_permissions(BACKDROP_ANONYMOUS_ROLE, array(
      'access content' => FALSE,
    ));

    // Set the block to a region to confirm block is available.
    $layout = layout_load('home');
    $block = $layout->addBlock('node', 'recent', 'content');

    // Set block title and variables.
    $block_title = $this->randomName();
    $block->settings['title'] = $block_title;
    $block->settings['title_display'] = LAYOUT_TITLE_CUSTOM;
    $block->settings['block_settings'] = array(
      'node_count' => 2,
    );
    $layout->save();

    // Test that block is not visible without nodes
    $this->backdropGet('');
    $this->assertText(t('No content available.'), 'Block with "No content available." found.');

    // Add some test nodes.
    $default_settings = array('uid' => $this->web_user->uid, 'type' => 'post');
    $node1 = $this->backdropCreateNode($default_settings);
    $node2 = $this->backdropCreateNode($default_settings);
    $node3 = $this->backdropCreateNode($default_settings);

    // Change the changed time for node so that we can test ordering.
    db_update('node')
      ->fields(array(
        'changed' => $node1->changed + 100,
      ))
      ->condition('nid', $node2->nid)
      ->execute();
    db_update('node')
      ->fields(array(
        'changed' => $node1->changed + 200,
      ))
      ->condition('nid', $node3->nid)
      ->execute();

    // Test that a user without the 'access content' permission cannot
    // see the block.
    $this->backdropLogout();
    $this->backdropGet('');
    $this->assertNoText($block_title, t('Block was not found.'));

    // Test that only the 2 latest nodes are shown.
    $this->backdropLogin($this->web_user);
    $this->backdropGet('');
    $this->assertNoText($node1->title, t('Node not found in block.'));
    $this->assertText($node2->title, t('Node found in block.'));
    $this->assertText($node3->title, t('Node found in block.'));

    // Check to make sure nodes are in the right order.
    $this->assertTrue($this->xpath('//*[contains(@class,"block-node-recent")]/div/table/tbody/tr[position() = 1]/td/div/a[text() = "' . $node3->title . '"]'), t('Nodes were ordered correctly in block.'));

    // Set the number of recent nodes to show to 10.
    $this->backdropLogout();
    $this->backdropLogin($this->admin_user);

    $block->settings['block_settings'] = array(
      'node_count' => 10,
    );
    $layout->save();

    // Post an additional node.
    $default_settings['type'] = 'page';
    $node4 = $this->backdropCreateNode($default_settings);
    // Clear page caches.
    cache_clear_all();

    // Test that all four nodes are shown.
    $this->backdropGet('');
    $this->assertText($node1->title, t('Node found in block.'));
    $this->assertText($node2->title, t('Node found in block.'));
    $this->assertText($node3->title, t('Node found in block.'));
    $this->assertText($node4->title, t('Node found in block.'));

    // Create the custom block.
    $custom_block = array();
    $custom_block['info'] = $this->randomName();
    $custom_block['delta'] = strtolower($this->randomName(8));
    $custom_block['title'] = $this->randomName();
    $custom_block['body[value]'] = $this->randomName(32);
    $this->backdropPost('admin/structure/block/add', $custom_block, t('Save block'));

    // Add a new layout with the node/% path.
    $edit = array(
      'title' => 'Post layout',
      'name' => 'post_layout',
      'layout_template' => 'moscone_flipped',
      'path' => 'node/%',
    );
    $this->backdropPost('admin/structure/layouts/add', $edit, t('Create layout'));

    // Add a condition to specify only the post type should have this layout.
    $this->backdropPost('admin/structure/layouts/manage/post_layout/configure', array(), t('Add visibility condition'));
    $this->backdropPost(NULL, array('condition' => 'node_type'), t('Load condition'));
    $this->backdropPost(NULL, array('bundles[post]' => 1), t('Add visibility condition'));
    $this->backdropPost(NULL, array(), t('Save layout'));

    // Add the custom block to the layout.
    $layout = layout_load('post_layout');
    $layout->addBlock('block', $custom_block['delta'], 'sidebar');
    $layout->save();

    // Verify visibility rules.
    $this->backdropGet('');
    $this->assertNoText($custom_block['title'], 'Block was not displayed the front page.');
    $this->backdropGet('node/' . $node1->nid);
    $this->assertText($custom_block['title'], 'Block was displayed on the post node.');
    $this->backdropGet('node/' . $node4->nid);
    $this->assertNoText($custom_block['title'], 'Block was not displayed on the page node.');
  }

  /**
   * Tests the Existing content block.
   */
  function testNodeBlock() {
    $this->backdropLogin($this->admin_user);

    // Add some test nodes.
    $node1_settings = array('uid' => $this->web_user->uid, 'type' => 'post');
    $node2_settings = array(
      'body' => array(LANGUAGE_NONE => array(array('value' => 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam vitae arcu at leo cursus laoreet. Curabitur dui tortor, adipiscing malesuada tempor in, bibendum ac diam. Cras non tellus a libero pellentesque condimentum. This is the middle. Suspendisse ac lacus libero. Ut non est vel nisl faucibus interdum nec sed leo. Pellentesque sem risus, vulputate eu semper eget, auctor in libero. Ut fermentum est vitae metus convallis scelerisque. Phasellus pellentesque rhoncus tellus, eu dignissim purus posuere id. Quisque eu fringilla ligula. Morbi ullamcorper, lorem et mattis egestas, tortor neque pretium velit, eget eleifend odio turpis eu purus. Donec vitae metus quis leo pretium tincidunt a pulvinar sem. Morbi adipiscing laoreet mauris vel placerat. Nullam elementum, nisl sit amet scelerisque malesuada, dolor nunc hendrerit quam, eu ultrices erat est in orci. Curabitur feugiat egestas nisl sed accumsan. This is the end.'))),
      'promote' => 1,
    );

    $node1 = $this->backdropCreateNode($node1_settings);
    $node2 = $this->backdropCreateNode($node2_settings);

    // Check that $node2 does not appear on $node1 path.
    $this->backdropGet('node/' . $node1->nid);
    $this->assertNoText($node2->title, t('Node 2 title not found on Node 1.'));

    // Add a Existing content block with default settings.
    $this->backdropGet('admin/structure/layouts/manage/default');
    $this->clickLink(t('Add block'), 3);
    $this->clickLink(t('Existing content'));
    $edit = array(
      'nid' => $node2->nid,
      'leave_node_title' => TRUE,
      'link_node_title' => TRUE,
      'links' => TRUE,
    );
    $this->backdropPost(NULL, $edit, t('Add block'));
    $first_block = $this->xpath('(//*[@id="layout-content-form"]//*[contains(@class,:region)]//*[@data-block-id])[last()]', array(
      ':region' => 'l-sidebar',
    ));
    $first_block_uuid = (string) $first_block[0]['data-block-id'];
    $this->backdropPost(NULL, array(), t('Save layout'));
    $this->backdropGet('node/' . $node1->nid);

    // Check that the title for $node2 only appears once on the page.
    $elements = $this->xpath('//*[text()="' . $node2->title . '"]');
    $this->assertEqual(count($elements), 1, 'The node title appears only once on the page.');

    // Test that the full node is shown.
    $this->assertText('This is the middle');
    $this->assertText('This is the end');

    // Read more text not found.
    $this->assertNoText('Read more');

    // The block title is linked to the node
    $elements = $this->xpath("//h2[contains(@class, :class)]//a[contains(@href, :href)]", array(':class' => 'block-title', ':href' => strtolower($node2->title)));
    $this->assertEqual(count($elements), 1, 'The block title is linked to the node');

    // Make several changes to the Existing content block settings.
    $edit = array(
      'leave_node_title' => FALSE,
      'link_node_title' => FALSE,
      'view_mode' => 'teaser',
    );
    $this->backdropPost('admin/structure/layouts/manage/default/configure-block/editor/' . $first_block_uuid, $edit, t('Update block'));
    $this->backdropPost(NULL, array(), t('Save layout'));
    $this->backdropGet('node/' . $node1->nid);

    // Check that $node2 title now only appears on $node1 path once
    $this->assertUniqueText($node2->title, 'The node title appears once on the page.');

    // The title is from the block title, not the node
    $elements = $this->xpath("//h2[contains(@class,':class') and text() = ':title']", array(':class' => 'block-title', ':title' => $node2->title));
    $this->assertFalse($elements, 'The block title is the node title.');

    // The title is not linked to the node.
    $elements = $this->xpath("//h2[contains(@class,':class')]//a[contains(@href,'node/:href')]", array(':class' => 'block-title', ':href' => $node2->nid));
    $this->assertFalse($elements, 'The block title is not linked to the node');

    // Test that the full node is not shown.
    $this->assertText('This is the middle');
    $this->assertNoText('This is the end');

    // Read more text now found.
    $this->assertText('Read more');
  }
}

/**
 * Test to ensure that a node's content is always rebuilt.
 */
class NodeBuildContent extends BackdropWebTestCase {
 /**
  * Ensures that content array is rebuilt on every call to node_build_content().
  */
  function testNodeRebuildContent() {
    $node = $this->backdropCreateNode();

    // Set a property in the content array so we can test for its existence later on.
    $node->content['test_content_property'] = array('#value' => $this->randomString());
    $content = node_build_content($node);

    // If the property doesn't exist it means the node->content was rebuilt.
    $this->assertFalse(isset($content['test_content_property']), t('Node content was emptied prior to being built.'));
  }
}

/**
 * Tests node_query_node_access_alter().
 */
class NodeQueryAlter extends BackdropWebTestCase {
  protected $profile = 'testing';

  /**
   * User with permission to view content.
   *
   * @var object
   */
  protected $accessUser;

  /**
   * User without permission to view content.
   *
   * @var object
   */
  protected $noAccessUser;

  function setUp() {
    parent::setUp('node_access_test');

    node_access_rebuild();

    // Create some content.
    $this->backdropCreateNode();
    $this->backdropCreateNode();
    $this->backdropCreateNode();
    $this->backdropCreateNode();

    // Create user with simple node access permission. The 'node test view'
    // permission is implemented and granted by the node_access_test module.
    $this->accessUser = $this->backdropCreateUser(array('access content overview', 'access content', 'node test view'));
    $this->noAccessUser = $this->backdropCreateUser(array('access content overview', 'access content'));
    $this->noAccessUser2 = $this->backdropCreateUser(array('access content overview', 'access content'));
  }

  /**
   * Tests that node access permissions are followed.
   */
  function testNodeQueryAlterWithUI() {
    // Verify that a user with access permission can see at least one node.
    $this->backdropLogin($this->accessUser);
    $this->backdropGet('node_access_test_page');
    $this->assertText('Yes, 4 nodes', "4 nodes were found for access user");
    $this->assertNoText('Exception', "No database exception");

    // Test the content overview page.
    $this->backdropGet('admin/content');
    $table_rows = $this->xpath('//tbody/tr');
    $this->assertEqual(4, count($table_rows), "4 nodes were found for access user");

    // Verify that a user with no access permission cannot see nodes.
    $this->backdropLogin($this->noAccessUser);
    $this->backdropGet('node_access_test_page');
    $this->assertText('No nodes', "No nodes were found for no access user");
    $this->assertNoText('Exception', "No database exception");

    $this->backdropGet('admin/content');
    $this->assertText(t('No content found.'));
  }

  /**
   * Tests 'node_access' query alter, for user with access.
   *
   * Verifies that a non-standard table alias can be used, and that a user with
   * node access can view the nodes.
   */
  function testNodeQueryAlterLowLevelWithAccess() {
    // User with access should be able to view 4 nodes.
    try {
      $query = db_select('node', 'mytab')
        ->fields('mytab');
      $query->addTag('node_access');
      $query->addMetaData('op', 'view');
      $query->addMetaData('account', $this->accessUser);

      $result = $query->execute()->fetchAll();
      $this->assertEqual(count($result), 4, t('User with access can see correct nodes'));
    }
    catch (Exception $e) {
      $this->fail(t('Altered query is malformed'));
    }
  }

  /**
   * Tests 'node_access' query alter, for user without access.
   *
   * Verifies that a non-standard table alias can be used, and that a user
   * without node access cannot view the nodes.
   */
  function testNodeQueryAlterLowLevelNoAccess() {
    // User without access should be able to view 0 nodes.
    try {
      $query = db_select('node', 'mytab')
        ->fields('mytab');
      $query->addTag('node_access');
      $query->addMetaData('op', 'view');
      $query->addMetaData('account', $this->noAccessUser);

      $result = $query->execute()->fetchAll();
      $this->assertEqual(count($result), 0, t('User with no access cannot see nodes'));
    }
    catch (Exception $e) {
      $this->fail(t('Altered query is malformed'));
    }
  }

  /**
   * Tests 'node_access' query alter, for edit access.
   *
   * Verifies that a non-standard table alias can be used, and that a user with
   * view-only node access cannot edit the nodes.
   */
  function testNodeQueryAlterLowLevelEditAccess() {
    // User with view-only access should not be able to edit nodes.
    try {
      $query = db_select('node', 'mytab')
        ->fields('mytab');
      $query->addTag('node_access');
      $query->addMetaData('op', 'update');
      $query->addMetaData('account', $this->accessUser);

      $result = $query->execute()->fetchAll();
      $this->assertEqual(count($result), 0, t('User with view-only access cannot edit nodes'));
    }
    catch (Exception $e) {
      $this->fail($e->getMessage());
      $this->fail((string) $query);
      $this->fail(t('Altered query is malformed'));
    }
  }

  /**
   * Tests 'node_access' query alter override.
   *
   * Verifies that node_access_view_all_nodes() is called from
   * node_query_node_access_alter(). We do this by checking that a user who
   * normally would not have view privileges is able to view the nodes when we
   * add a record to {node_access} paired with a corresponding privilege in
   * hook_node_grants().
   */
  function testNodeQueryAlterOverride() {
    $record = array(
      'nid' => 0,
      'gid' => 0,
      'realm' => 'node_access_all',
      'grant_view' => 1,
      'grant_update' => 0,
      'grant_delete' => 0,
    );
    backdrop_write_record('node_access', $record);

    // Test that the noAccessUser still doesn't have the 'view'
    // privilege after adding the node_access record.
    backdrop_static_reset('node_access_view_all_nodes');
    try {
      $query = db_select('node', 'mytab')
        ->fields('mytab');
      $query->addTag('node_access');
      $query->addMetaData('op', 'view');
      $query->addMetaData('account', $this->noAccessUser);

      $result = $query->execute()->fetchAll();
      $this->assertEqual(count($result), 0, t('User view privileges are not overridden'));
    }
    catch (Exception $e) {
      $this->fail(t('Altered query is malformed'));
    }

    // Have node_test_node_grants return a node_access_all privilege,
    // to grant the noAccessUser 'view' access.  To verify that
    // node_access_view_all_nodes is properly checking the specified
    // $account instead of the global $user, we will log in as
    // noAccessUser2.
    $this->backdropLogin($this->noAccessUser2);
    state_set('node_test_node_access_all_uid', $this->noAccessUser->uid);
    backdrop_static_reset('node_access_view_all_nodes');
    try {
      $query = db_select('node', 'mytab')
        ->fields('mytab');
      $query->addTag('node_access');
      $query->addMetaData('op', 'view');
      $query->addMetaData('account', $this->noAccessUser);

      $result = $query->execute()->fetchAll();
      $this->assertEqual(count($result), 4, t('User view privileges are overridden'));
    }
    catch (Exception $e) {
      $this->fail(t('Altered query is malformed'));
    }
    state_del('node_test_node_access_all_uid');
  }
}


/**
 * Tests node_query_entity_field_access_alter().
 */
class NodeEntityFieldQueryAlter extends BackdropWebTestCase {
  /**
   * User with permission to view content.
   *
   * @var object
   */
  protected $accessUser;

  /**
   * User without permission to view content.
   *
   * @var object
   */
  protected $noAccessUser;

  function setUp() {
    parent::setUp('node_access_test');
    node_access_rebuild();

    // Creating 4 nodes with an entity field so we can test that sort of query
    // alter. All field values starts with 'A' so we can identify and fetch them
    // in the node_access_test module.
    $settings = array('langcode' => LANGUAGE_NONE);
    for ($i = 0; $i < 4; $i++) {
      $body = array(
        'value' => 'A' . $this->randomName(32),
        'format' => filter_default_format(),
      );
      $settings['body'][LANGUAGE_NONE][0] = $body;
      $this->backdropCreateNode($settings);
    }

    // Create user with simple node access permission. The 'node test view'
    // permission is implemented and granted by the node_access_test module.
    $this->accessUser = $this->backdropCreateUser(array('access content', 'node test view'));
    $this->noAccessUser = $this->backdropCreateUser(array('access content'));
  }

  /**
   * Tests that node access permissions are followed.
   */
  function testNodeQueryAlterWithUI() {
    // Verify that a user with access permission can see at least one node.
    $this->backdropLogin($this->accessUser);
    $this->backdropGet('node_access_entity_test_page');
    $this->assertText('Yes, 4 nodes', "4 nodes were found for access user");
    $this->assertNoText('Exception', "No database exception");

    // Verify that a user with no access permission cannot see nodes.
    $this->backdropLogin($this->noAccessUser);
    $this->backdropGet('node_access_entity_test_page');
    $this->assertText('No nodes', "No nodes were found for no access user");
    $this->assertNoText('Exception', "No database exception");
  }
}

/**
 * Test node token replacement in strings.
 */
class NodeTokenReplaceTestCase extends BackdropWebTestCase {
  /**
   * Creates a node, then tests the tokens generated from it.
   */
  function testNodeTokenReplacement() {
    global $language;
    $url_options = array(
      'absolute' => TRUE,
      'language' => $language,
    );

    // Create a user and a node.
    $account = $this->backdropCreateUser();
    $settings = array(
      'type' => 'post',
      'uid' => $account->uid,
      'title' => '<blink>Blinking Text</blink>',
      'body' => array(LANGUAGE_NONE => array(array('value' => $this->randomName(32), 'summary' => $this->randomName(16)))),
    );
    $node = $this->backdropCreateNode($settings);

    // Load node so that the body and summary fields are structured properly.
    $node = node_load($node->nid);
    $instance = field_info_instance('node', 'body', $node->type);

    // Generate and test sanitized tokens.
    $tests = array();
    $tests['[node:nid]'] = $node->nid;
    $tests['[node:vid]'] = $node->vid;
    $tests['[node:tnid]'] = $node->tnid;
    $tests['[node:type]'] = 'post';
    $tests['[node:type-name]'] = 'Post';
    $tests['[node:title]'] = check_plain($node->title);
    $tests['[node:body]'] = _text_sanitize($instance, $node->langcode, $node->body[$node->langcode][0], 'value');
    $tests['[node:summary]'] = _text_sanitize($instance, $node->langcode, $node->body[$node->langcode][0], 'summary');
    $tests['[node:langcode]'] = check_plain($node->langcode);
    $tests['[node:url]'] = url('node/' . $node->nid, $url_options);
    $tests['[node:edit-url]'] = url('node/' . $node->nid . '/edit', $url_options);
    $tests['[node:author]'] = check_plain(user_format_name($account));
    $tests['[node:author:uid]'] = $node->uid;
    $tests['[node:author:name]'] = check_plain(user_format_name($account));
    $tests['[node:created:since]'] = format_interval(REQUEST_TIME - $node->created, 2, $language->langcode);
    $tests['[node:changed:since]'] = format_interval(REQUEST_TIME - $node->changed, 2, $language->langcode);

    // Test to make sure that we generated something for each token.
    $this->assertFalse(in_array(0, array_map('strlen', $tests)), t('No empty tokens generated.'));

    foreach ($tests as $input => $expected) {
      $output = token_replace($input, array('node' => $node), array('language' => $language));
      $this->assertEqual($output, $expected, t('Sanitized node token %token replaced.', array('%token' => $input)));
    }

    // Generate and test unsanitized tokens.
    $tests['[node:title]'] = $node->title;
    $tests['[node:body]'] = $node->body[$node->langcode][0]['value'];
    $tests['[node:summary]'] = $node->body[$node->langcode][0]['summary'];
    $tests['[node:langcode]'] = $node->langcode;
    $tests['[node:author:name]'] = user_format_name($account);

    foreach ($tests as $input => $expected) {
      $output = token_replace($input, array('node' => $node), array('language' => $language, 'sanitize' => FALSE));
      $this->assertEqual($output, $expected, t('Unsanitized node token %token replaced.', array('%token' => $input)));
    }

    // Repeat for a node without a summary.
    $settings['body'] = array(LANGUAGE_NONE => array(array('value' => $this->randomName(32), 'summary' => '')));
    $node = $this->backdropCreateNode($settings);

    // Load node (without summary) so that the body and summary fields are
    // structured properly.
    $node = node_load($node->nid);
    $instance = field_info_instance('node', 'body', $node->type);

    // Generate and test sanitized token - use full body as expected value.
    $tests = array();
    $tests['[node:summary]'] = _text_sanitize($instance, $node->langcode, $node->body[$node->langcode][0], 'value');

    // Test to make sure that we generated something for each token.
    $this->assertFalse(in_array(0, array_map('strlen', $tests)), 'No empty tokens generated for node without a summary.');

    foreach ($tests as $input => $expected) {
      $output = token_replace($input, array('node' => $node), array('language' => $language));
      $this->assertEqual($output, $expected, format_string('Sanitized node token %token replaced for node without a summary.', array('%token' => $input)));
    }

    // Generate and test unsanitized tokens.
    $tests['[node:summary]'] = $node->body[$node->langcode][0]['value'];

    foreach ($tests as $input => $expected) {
      $output = token_replace($input, array('node' => $node), array('language' => $language, 'sanitize' => FALSE));
      $this->assertEqual($output, $expected, format_string('Unsanitized node token %token replaced for node without a summary.', array('%token' => $input)));
    }
  }
}

/**
 * Tests user permissions for node revisions.
 */
class NodeRevisionPermissionsTestCase extends BackdropWebTestCase {

  /**
   * Nodes used by the test.
   *
   * @var array
   */
  protected $node_revisions = array();

  /**
   * Users with different revision permission used by the test.
   *
   * @var array
   */
  protected $accounts = array();

  /**
   * Map revision permission names to node revision access ops.
   *
   * @var array
   */
  protected $map = array(
    'view' => 'view revisions',
    'update' => 'revert revisions',
    'delete' => 'delete revisions',
  );

  function setUp() {
    parent::setUp();

    // Create a node with several revisions.
    $node = $this->backdropCreateNode();
    $this->node_revisions[] = $node;

    for ($i = 0; $i < 3; $i++) {
      // Create a revision for the same nid and settings with a random log.
      $revision = clone $node;
      $revision->revision = 1;
      $revision->log = $this->randomName(32);
      node_save($revision);
      $this->node_revisions[] = $revision;
    }

    // Create three users, one with each revision permission.
    foreach ($this->map as $op => $permission) {
      // Create the user.
      $account = $this->backdropCreateUser(
        array(
          'access content',
          'edit any page content',
          'delete any page content',
          $permission,
        )
      );
      $account->op = $op;
      $this->accounts[] = $account;
    }

    // Create an admin account (returns TRUE for all revision permissions).
    $admin_account = $this->backdropCreateUser(array('access content', 'administer nodes'));
    $admin_account->is_admin = TRUE;
    $this->accounts['admin'] = $admin_account;

    // Create a normal account (returns FALSE for all revision permissions).
    $normal_account = $this->backdropCreateUser();
    $normal_account->op = FALSE;
    $this->accounts[] = $normal_account;
  }

  /**
   * Tests the _node_revision_access() function.
   */
  function testNodeRevisionAccess() {
    $revision = $this->node_revisions[1];

    $parameters = array(
      'op' => array_keys($this->map),
      'account' => $this->accounts,
    );

    $permutations = $this->generatePermutations($parameters);
    foreach ($permutations as $case) {
      if (!empty($case['account']->is_admin) || $case['op'] == $case['account']->op) {
        $this->assertTrue(_node_revision_access($revision, $case['op'], $case['account']), "{$this->map[$case['op']]} granted.");
      }
      else {
        $this->assertFalse(_node_revision_access($revision, $case['op'], $case['account']), "{$this->map[$case['op']]} not granted.");
      }
    }

    // Test that access is FALSE for a node administrator with an invalid $node
    // or $op parameters.
    $admin_account = $this->accounts['admin'];
    $this->assertFalse(_node_revision_access($revision, 'invalid-op', $admin_account), '_node_revision_access() returns FALSE with an invalid op.');

    // Test that the $account parameter defaults to the "logged in" user.
    $original_user = $GLOBALS['user'];
    $GLOBALS['user'] = $admin_account;
    $this->assertTrue(_node_revision_access($revision, 'view'), '_node_revision_access() returns TRUE when used with global user.');
    $GLOBALS['user'] = $original_user;
  }
}

/**
 * Tests pagination with a node access module enabled.
 */
class NodeAccessPagerTestCase extends BackdropWebTestCase {
  public function setUp() {
    parent::setUp('node_access_test', 'comment');
    node_access_rebuild();
    $this->web_user = $this->backdropCreateUser(array('access content', 'access comments', 'node test view'));
  }

  /**
   * Tests the comment pager for nodes with multiple grants per realm.
   */
  public function testCommentPager() {
    // Create a node.
    $node = $this->backdropCreateNode();

    // Create 60 comments.
    for ($i = 0; $i < 60; $i++) {
      $comment = entity_create('comment', array(
        'uid' => $this->web_user->uid,
        'nid' => $node->nid,
        'subject' => $this->randomName(),
        'comment_body' => array(
          LANGUAGE_NONE => array(
            array('value' => $this->randomName()),
          ),
        ),
      ));
      comment_save($comment);
    }

    $this->backdropLogin($this->web_user);

    // View the node page. With the default 50 comments per page there should
    // be two pages (0, 1) but no third (2) page.
    $this->backdropGet('node/' . $node->nid);
    $this->assertText($node->title);
    $this->assertText('Comments');
    $this->assertRaw('page=1');
    $this->assertNoRaw('page=2');
  }
}

/*
 * Tests the interaction of the node access system with fields.
 */
class NodeAccessFieldTestCase extends NodeWebTestCase {
  public function setUp() {
    parent::setUp('node_access_test', 'field_ui');
    node_access_rebuild();

    // Create some users.
    $this->admin_user = $this->backdropCreateUser(array('access content', 'bypass node access', 'administer fields'));
    $this->content_admin_user = $this->backdropCreateUser(array('access content', 'administer content types', 'administer fields'));

    // Add a custom field to the page content type.
    $this->field_name = backdrop_strtolower($this->randomName() . '_field_name');
    $this->field = field_create_field(array('field_name' => $this->field_name, 'type' => 'text'));
    $this->instance = field_create_instance(array(
      'field_name' => $this->field_name,
      'entity_type' => 'node',
      'bundle' => 'page',
    ));
  }

  /**
   * Tests administering fields when node access is restricted.
   */
  function testNodeAccessAdministerField() {
    // Create a page node.
    $langcode = LANGUAGE_NONE;
    $field_data = array();
    $value = $field_data[$langcode][0]['value'] = $this->randomName();
    $node = $this->backdropCreateNode(array($this->field_name => $field_data));

    // Log in as the administrator and confirm that the field value is present.
    $this->backdropLogin($this->admin_user);
    $this->backdropGet("node/{$node->nid}");
    $this->assertText($value, 'The saved field value is visible to an administrator.');

    // Log in as the content admin and try to view the node.
    $this->backdropLogin($this->content_admin_user);
    $this->backdropGet("node/{$node->nid}");
    $this->assertText('Access denied', 'Access is denied for the content admin.');

    // Modify the field default as the content admin.
    $edit = array();
    $default = 'Sometimes words have two meanings';
    $edit["{$this->field_name}[$langcode][0][value]"] = $default;
    $this->backdropPost(
      "admin/structure/types/manage/page/fields/{$this->field_name}",
      $edit,
      t('Save settings')
    );

    // Log in as the administrator.
    $this->backdropLogin($this->admin_user);

    // Confirm that the existing node still has the correct field value.
    $this->backdropGet("node/{$node->nid}");
    $this->assertText($value, 'The original field value is visible to an administrator.');

    // Confirm that the new default value appears when creating a new node.
    $this->backdropGet('node/add/page');
    $this->assertRaw($default, 'The updated default value is displayed when creating a new node.');
  }
}

/**
 * Tests changing view modes for nodes.
 */
class NodeEntityViewModeAlterTest extends NodeWebTestCase {
  function setUp() {
    parent::setUp(array('node_test'));
  }

  /**
   * Create a "Page" node and verify its consistency in the database.
   */
  function testNodeViewModeChange() {
    $web_user = $this->backdropCreateUser(array('create page content', 'edit own page content'));
    $this->backdropLogin($web_user);

    // Create a node.
    $edit = array();
    $langcode = LANGUAGE_NONE;
    $edit["title"] = $this->randomName(8);
    $edit["body[$langcode][0][value]"] = 'Data that should appear only in the body for the node.';
    $edit["body[$langcode][0][summary]"] = 'Extra data that should appear only in the teaser for the node.';
    $this->backdropPost('node/add/page', $edit, t('Save'));

    $node = $this->backdropGetNodeByTitle($edit["title"]);

    // Set the flag to alter the view mode and view the node.
    state_set('node_test_change_view_mode', 'teaser');
    $this->backdropGet('node/' . $node->nid);

    // Check that teaser mode is viewed.
    $this->assertText('Extra data that should appear only in the teaser for the node.', 'Teaser text present');
    // Make sure body text is not present.
    $this->assertNoText('Data that should appear only in the body for the node.', 'Body text not present');

    // Test that the correct build mode has been set.
    $build = node_view($node);
    $this->assertEqual($build['#view_mode'], 'teaser', 'The view mode has correctly been set to teaser.');
  }

  /**
   * Tests fields that were previously hidden when the view mode is changed.
   */
  function testNodeViewModeChangeHiddenField() {
    // Hide the tags field on the default display
    $instance = field_info_instance('node', 'field_tags', 'post');
    $instance['display']['default']['type'] = 'hidden';
    field_update_instance($instance);

    $web_user = $this->backdropCreateUser(array('create post content', 'edit own post content'));
    $this->backdropLogin($web_user);

    // Create a node.
    $edit = array();
    $langcode = LANGUAGE_NONE;
    $edit["title"] = $this->randomName(8);
    $edit["body[$langcode][0][value]"] = 'Data that should appear only in the body for the node.';
    $edit["body[$langcode][0][summary]"] = 'Extra data that should appear only in the teaser for the node.';
    $edit["field_tags[$langcode]"] = 'Extra tag';
    $this->backdropPost('node/add/post', $edit, t('Save'));

    $node = $this->backdropGetNodeByTitle($edit["title"]);

    // Set the flag to alter the view mode and view the node.
    state_set('node_test_change_view_mode', 'teaser');
    $this->backdropGet('node/' . $node->nid);

    // Check that teaser mode is viewed.
    $this->assertText('Extra data that should appear only in the teaser for the node.', 'Teaser text present');
    // Make sure body text is not present.
    $this->assertNoText('Data that should appear only in the body for the node.', 'Body text not present');
    // Make sure tags are present.
    $this->assertText('Extra tag', 'Taxonomy term present');

    // Test that the correct build mode has been set.
    $build = node_view($node);
    $this->assertEqual($build['#view_mode'], 'teaser', 'The view mode has correctly been set to teaser.');
  }
}

/**
 * Tests the cache invalidation of node operations.
 */
class NodePageCacheTest extends NodeWebTestCase {
  protected $profile = 'minimal';

  /**
   * An admin user with administrative permissions for nodes.
   */
  protected $admin_user;

  function setUp() {
    parent::setUp();

    config_set('system.core', 'cache', 1);
    config_set('system.core', 'page_cache_maximum_age', 300);

    $this->backdropCreateContentType(array(
      'type' => 'page',
      'name' => 'Page',
    ));

    $this->admin_user = $this->backdropCreateUser(array(
        'bypass node access',
        'access content overview',
        'administer nodes',
    ));
  }

  /**
   * Tests deleting nodes clears page cache.
   */
  public function testNodeDelete() {
    $node_path = 'node/' . $this->backdropCreateNode()->nid;

    // Populate page cache.
    $this->backdropGet($node_path);

    // Login and delete the node.
    $this->backdropLogin($this->admin_user);
    $this->backdropPost($node_path . '/delete', array(), t('Delete'));

    // Logout. The node will still be accessible due to the page cache.
    $this->backdropLogout();
    $this->backdropGet($node_path);
    $this->assertResponse(200);

    // Create two new nodes.
    $nodes[0] = $this->backdropCreateNode();
    $nodes[1] = $this->backdropCreateNode();
    $node_path = 'node/' . $nodes[0]->nid;

    // Populate page cache.
    $this->backdropGet($node_path);

    // Login and delete the nodes.
    $this->backdropLogin($this->admin_user);
    $this->backdropGet('admin/content');
    $edit = array(
        'action' => 'node_delete_action',
        'bulk_form[0]' => TRUE,
        'bulk_form[1]' => TRUE,
    );
    $this->backdropPost(NULL, $edit, t('Execute'));
    $this->backdropPost(NULL, array(), t('Delete'));

    // Logout and check the node is not available.
    $this->backdropLogout();
    $this->backdropGet($node_path);
    $this->assertResponse(404);
  }
}

/**
 * Tests that multi-byte UTF-8 characters are stored and retrieved correctly.
 */
class NodeMultiByteUtf8Test extends NodeWebTestCase {
  /**
   * Tests that multi-byte UTF-8 characters are stored and retrieved correctly.
   */
  public function testMultiByteUtf8() {
    $connection = Database::getConnection();
    // On MySQL, this test will only run if 'charset' is set to 'utf8mb4' in
    // settings.php.
    if (!($connection->utf8mb4IsSupported() && $connection->utf8mb4IsActive())) {
      return;
    }
    $title = '';
    $this->assertTrue(backdrop_strlen($title) < strlen($title), 'Title has multi-byte characters.');
    $node = $this->backdropCreateNode(array('title' => $title));
    $this->backdropGet('node/' . $node->nid);
    $result = $this->xpath('//h1[@id="page-title"]');
    $this->assertEqual(trim((string) $result[0]), $title, 'The passed title was returned.');
  }

}
